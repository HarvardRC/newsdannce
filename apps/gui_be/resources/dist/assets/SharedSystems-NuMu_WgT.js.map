{"version":3,"file":"SharedSystems-NuMu_WgT.js","sources":["../../node_modules/pixi.js/lib/filters/Filter.mjs","../../node_modules/pixi.js/lib/filters/mask/mask.frag.mjs","../../node_modules/pixi.js/lib/filters/mask/mask.vert.mjs","../../node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs","../../node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs","../../node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs","../../node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs","../../node_modules/pixi.js/lib/scene/container/utils/buildInstructions.mjs","../../node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs","../../node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs","../../node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs","../../node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs","../../node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs","../../node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs","../../node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs","../../node_modules/pixi.js/lib/scene/container/utils/clearList.mjs","../../node_modules/pixi.js/lib/scene/container/utils/collectRenderGroups.mjs","../../node_modules/pixi.js/lib/scene/container/utils/mixHexColors.mjs","../../node_modules/pixi.js/lib/scene/container/utils/mixColors.mjs","../../node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs","../../node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs","../../node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs","../../node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.mjs","../../node_modules/pixi.js/lib/utils/sayHello.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs","../../node_modules/pixi.js/lib/utils/data/clean.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs","../../node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs"],"sourcesContent":["import { GlProgram } from '../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { Shader } from '../rendering/renderers/shared/shader/Shader.mjs';\nimport { State } from '../rendering/renderers/shared/state/State.mjs';\n\n\"use strict\";\nconst _Filter = class _Filter extends Shader {\n  /**\n   * @param options - The optional parameters of this filter.\n   */\n  constructor(options) {\n    options = { ..._Filter.defaultOptions, ...options };\n    super(options);\n    /** If enabled is true the filter is applied, if false it will not. */\n    this.enabled = true;\n    /**\n     * The gpu state the filter requires to render.\n     * @internal\n     * @ignore\n     */\n    this._state = State.for2d();\n    this.blendMode = options.blendMode;\n    this.padding = options.padding;\n    if (typeof options.antialias === \"boolean\") {\n      this.antialias = options.antialias ? \"on\" : \"off\";\n    } else {\n      this.antialias = options.antialias;\n    }\n    this.resolution = options.resolution;\n    this.blendRequired = options.blendRequired;\n    this.clipToViewport = options.clipToViewport;\n    this.addResource(\"uTexture\", 0, 1);\n  }\n  /**\n   * Applies the filter\n   * @param filterManager - The renderer to retrieve the filter from\n   * @param input - The input render target.\n   * @param output - The target to output to.\n   * @param clearMode - Should the output be cleared before rendering to it\n   */\n  apply(filterManager, input, output, clearMode) {\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * Get the blend mode of the filter.\n   * @default \"normal\"\n   */\n  get blendMode() {\n    return this._state.blendMode;\n  }\n  /** Sets the blend mode of the filter. */\n  set blendMode(value) {\n    this._state.blendMode = value;\n  }\n  /**\n   * A short hand function to create a filter based of a vertex and fragment shader src.\n   * @param options\n   * @returns A shiny new PixiJS filter!\n   */\n  static from(options) {\n    const { gpu, gl, ...rest } = options;\n    let gpuProgram;\n    let glProgram;\n    if (gpu) {\n      gpuProgram = GpuProgram.from(gpu);\n    }\n    if (gl) {\n      glProgram = GlProgram.from(gl);\n    }\n    return new _Filter({\n      gpuProgram,\n      glProgram,\n      ...rest\n    });\n  }\n};\n/**\n * The default filter settings\n * @static\n */\n_Filter.defaultOptions = {\n  blendMode: \"normal\",\n  resolution: 1,\n  padding: 0,\n  antialias: \"off\",\n  blendRequired: false,\n  clipToViewport: true\n};\nlet Filter = _Filter;\n\nexport { Filter };\n//# sourceMappingURL=Filter.mjs.map\n","var fragment = \"in vec2 vMaskCoord;\\nin vec2 vTextureCoord;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMaskTexture;\\n\\nuniform float uAlpha;\\nuniform vec4 uMaskClamp;\\nuniform float uInverse;\\n\\nout vec4 finalColor;\\n\\nvoid main(void)\\n{\\n    float clip = step(3.5,\\n        step(uMaskClamp.x, vMaskCoord.x) +\\n        step(uMaskClamp.y, vMaskCoord.y) +\\n        step(vMaskCoord.x, uMaskClamp.z) +\\n        step(vMaskCoord.y, uMaskClamp.w));\\n\\n    // TODO look into why this is needed\\n    float npmAlpha = uAlpha;\\n    vec4 original = texture(uTexture, vTextureCoord);\\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\\n\\n    float a = alphaMul * masky.r * npmAlpha * clip;\\n\\n    if (uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    finalColor = original * a;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=mask.frag.mjs.map\n","var vertex = \"in vec2 aPosition;\\n\\nout vec2 vTextureCoord;\\nout vec2 vMaskCoord;\\n\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\nuniform mat3 uFilterMatrix;\\n\\nvec4 filterVertexPosition(  vec2 aPosition )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n       \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord(  vec2 aPosition )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvec2 getFilterCoord( vec2 aPosition )\\n{\\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}   \\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition(aPosition);\\n    vTextureCoord = filterTextureCoord(aPosition);\\n    vMaskCoord = getFilterCoord(aPosition);\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=mask.vert.mjs.map\n","var source = \"struct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct MaskUniforms {\\n  uFilterMatrix:mat3x3<f32>,\\n  uMaskClamp:vec4<f32>,\\n  uAlpha:f32,\\n  uInverse:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) filterUv : vec2<f32>,\\n};\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);\\n}\\n\\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n\\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>,\\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition),\\n   getFilterCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) filterUv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n\\n    var maskClamp = filterUniforms.uMaskClamp;\\n    var uAlpha = filterUniforms.uAlpha;\\n\\n    var clip = step(3.5,\\n      step(maskClamp.x, filterUv.x) +\\n      step(maskClamp.y, filterUv.y) +\\n      step(filterUv.x, maskClamp.z) +\\n      step(filterUv.y, maskClamp.w));\\n\\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\\n    var source = textureSample(uTexture, uSampler, uv);\\n    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);\\n\\n    var a: f32 = alphaMul * mask.r * uAlpha * clip;\\n\\n    if (filterUniforms.uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    return source * a;\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=mask.wgsl.mjs.map\n","import { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { GlProgram } from '../../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { TextureMatrix } from '../../rendering/renderers/shared/texture/TextureMatrix.mjs';\nimport { Filter } from '../Filter.mjs';\nimport fragment from './mask.frag.mjs';\nimport vertex from './mask.vert.mjs';\nimport source from './mask.wgsl.mjs';\n\n\"use strict\";\nclass MaskFilter extends Filter {\n  constructor(options) {\n    const { sprite, ...rest } = options;\n    const textureMatrix = new TextureMatrix(sprite.texture);\n    const filterUniforms = new UniformGroup({\n      uFilterMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uMaskClamp: { value: textureMatrix.uClampFrame, type: \"vec4<f32>\" },\n      uAlpha: { value: 1, type: \"f32\" },\n      uInverse: { value: options.inverse ? 1 : 0, type: \"f32\" }\n    });\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"mask-filter\"\n    });\n    super({\n      ...rest,\n      gpuProgram,\n      glProgram,\n      resources: {\n        filterUniforms,\n        uMaskTexture: sprite.texture.source\n      }\n    });\n    this.sprite = sprite;\n    this._textureMatrix = textureMatrix;\n  }\n  set inverse(value) {\n    this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;\n  }\n  get inverse() {\n    return this.resources.filterUniforms.uniforms.uInverse === 1;\n  }\n  apply(filterManager, input, output, clearMode) {\n    this._textureMatrix.texture = this.sprite.texture;\n    filterManager.calculateSpriteMatrix(\n      this.resources.filterUniforms.uniforms.uFilterMatrix,\n      this.sprite\n    ).prepend(this._textureMatrix.mapCoord);\n    this.resources.uMaskTexture = this.sprite.texture.source;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n}\n\nexport { MaskFilter };\n//# sourceMappingURL=MaskFilter.mjs.map\n","import { ExtensionType, extensions } from '../../../extensions/Extensions.mjs';\nimport { State } from '../../renderers/shared/state/State.mjs';\nimport { DefaultBatcher } from './DefaultBatcher.mjs';\n\n\"use strict\";\nconst _BatcherPipe = class _BatcherPipe {\n  constructor(renderer, adaptor) {\n    this.state = State.for2d();\n    this._batchersByInstructionSet = /* @__PURE__ */ Object.create(null);\n    /** A record of all active batchers, keyed by their names */\n    this._activeBatches = /* @__PURE__ */ Object.create(null);\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init?.(this);\n  }\n  static getBatcher(name) {\n    return new this._availableBatchers[name]();\n  }\n  buildStart(instructionSet) {\n    let batchers = this._batchersByInstructionSet[instructionSet.uid];\n    if (!batchers) {\n      batchers = this._batchersByInstructionSet[instructionSet.uid] = /* @__PURE__ */ Object.create(null);\n      batchers.default || (batchers.default = new DefaultBatcher());\n    }\n    this._activeBatches = batchers;\n    this._activeBatch = this._activeBatches.default;\n    for (const i in this._activeBatches) {\n      this._activeBatches[i].begin();\n    }\n  }\n  addToBatch(batchableObject, instructionSet) {\n    if (this._activeBatch.name !== batchableObject.batcherName) {\n      this._activeBatch.break(instructionSet);\n      let batch = this._activeBatches[batchableObject.batcherName];\n      if (!batch) {\n        batch = this._activeBatches[batchableObject.batcherName] = _BatcherPipe.getBatcher(batchableObject.batcherName);\n        batch.begin();\n      }\n      this._activeBatch = batch;\n    }\n    this._activeBatch.add(batchableObject);\n  }\n  break(instructionSet) {\n    this._activeBatch.break(instructionSet);\n  }\n  buildEnd(instructionSet) {\n    this._activeBatch.break(instructionSet);\n    const batches = this._activeBatches;\n    for (const i in batches) {\n      const batch = batches[i];\n      const geometry = batch.geometry;\n      geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);\n      geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);\n    }\n  }\n  upload(instructionSet) {\n    const batchers = this._batchersByInstructionSet[instructionSet.uid];\n    for (const i in batchers) {\n      const batcher = batchers[i];\n      const geometry = batcher.geometry;\n      if (batcher.dirty) {\n        batcher.dirty = false;\n        geometry.buffers[0].update(batcher.attributeSize * 4);\n      }\n    }\n  }\n  execute(batch) {\n    if (batch.action === \"startBatch\") {\n      const batcher = batch.batcher;\n      const geometry = batcher.geometry;\n      const shader = batcher.shader;\n      this._adaptor.start(this, geometry, shader);\n    }\n    this._adaptor.execute(this, batch);\n  }\n  destroy() {\n    this.state = null;\n    this.renderer = null;\n    this._adaptor = null;\n    for (const i in this._activeBatches) {\n      this._activeBatches[i].destroy();\n    }\n    this._activeBatches = null;\n  }\n};\n/** @ignore */\n_BatcherPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"batch\"\n};\n_BatcherPipe._availableBatchers = /* @__PURE__ */ Object.create(null);\nlet BatcherPipe = _BatcherPipe;\nextensions.handleByMap(ExtensionType.Batcher, BatcherPipe._availableBatchers);\nextensions.add(DefaultBatcher);\n\nexport { BatcherPipe };\n//# sourceMappingURL=BatcherPipe.mjs.map\n","\"use strict\";\nconst textureBit = {\n  name: \"texture-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n         \n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            outColor = textureSample(uTexture, uSampler, vUV);\n        `\n    )\n  }\n};\nconst textureBitGl = {\n  name: \"texture-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTextureMatrix;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n        uniform sampler2D uTexture;\n\n         \n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            outColor = texture(uTexture, vUV);\n        `\n    )\n  }\n};\n\nexport { textureBit, textureBitGl };\n//# sourceMappingURL=textureBit.mjs.map\n","\"use strict\";\nfunction buildInstructions(renderGroup, rendererOrPipes) {\n  const root = renderGroup.root;\n  const instructionSet = renderGroup.instructionSet;\n  instructionSet.reset();\n  const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;\n  const renderPipes = renderer.renderPipes;\n  renderPipes.batch.buildStart(instructionSet);\n  renderPipes.blendMode.buildStart();\n  renderPipes.colorMask.buildStart();\n  if (root.sortableChildren) {\n    root.sortChildren();\n  }\n  collectAllRenderablesAdvanced(root, instructionSet, renderer, true);\n  renderPipes.batch.buildEnd(instructionSet);\n  renderPipes.blendMode.buildEnd(instructionSet);\n}\nfunction collectAllRenderables(container, instructionSet, rendererOrPipes) {\n  const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;\n  if (container.globalDisplayStatus < 7 || !container.includeInBuild)\n    return;\n  if (container.sortableChildren) {\n    container.sortChildren();\n  }\n  if (container.isSimple) {\n    collectAllRenderablesSimple(container, instructionSet, renderer);\n  } else {\n    collectAllRenderablesAdvanced(container, instructionSet, renderer, false);\n  }\n}\nfunction collectAllRenderablesSimple(container, instructionSet, renderer) {\n  if (container.renderPipeId) {\n    const renderable = container;\n    const { renderPipes, renderableGC } = renderer;\n    renderPipes.blendMode.setBlendMode(renderable, container.groupBlendMode, instructionSet);\n    const rp = renderPipes;\n    rp[renderable.renderPipeId].addRenderable(renderable, instructionSet);\n    renderableGC.addRenderable(renderable, instructionSet);\n    renderable.didViewUpdate = false;\n  }\n  if (!container.renderGroup) {\n    const children = container.children;\n    const length = children.length;\n    for (let i = 0; i < length; i++) {\n      collectAllRenderables(children[i], instructionSet, renderer);\n    }\n  }\n}\nfunction collectAllRenderablesAdvanced(container, instructionSet, renderer, isRoot) {\n  const { renderPipes, renderableGC } = renderer;\n  if (!isRoot && container.renderGroup) {\n    renderPipes.renderGroup.addRenderGroup(container.renderGroup, instructionSet);\n  } else {\n    for (let i = 0; i < container.effects.length; i++) {\n      const effect = container.effects[i];\n      const pipe = renderPipes[effect.pipe];\n      pipe.push(effect, container, instructionSet);\n    }\n    const renderable = container;\n    const renderPipeId = renderable.renderPipeId;\n    if (renderPipeId) {\n      renderPipes.blendMode.setBlendMode(renderable, renderable.groupBlendMode, instructionSet);\n      const pipe = renderPipes[renderPipeId];\n      pipe.addRenderable(renderable, instructionSet);\n      renderableGC.addRenderable(renderable, instructionSet);\n      renderable.didViewUpdate = false;\n    }\n    const children = container.children;\n    if (children.length) {\n      for (let i = 0; i < children.length; i++) {\n        collectAllRenderables(children[i], instructionSet, renderer);\n      }\n    }\n    for (let i = container.effects.length - 1; i >= 0; i--) {\n      const effect = container.effects[i];\n      const pipe = renderPipes[effect.pipe];\n      pipe.pop(effect, container, instructionSet);\n    }\n  }\n}\n\nexport { buildInstructions, collectAllRenderables };\n//# sourceMappingURL=buildInstructions.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { FilterEffect } from '../../../filters/FilterEffect.mjs';\nimport { MaskFilter } from '../../../filters/mask/MaskFilter.mjs';\nimport { Bounds } from '../../../scene/container/bounds/Bounds.mjs';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds.mjs';\nimport { collectAllRenderables } from '../../../scene/container/utils/buildInstructions.mjs';\nimport { Sprite } from '../../../scene/sprite/Sprite.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { Texture } from '../../renderers/shared/texture/Texture.mjs';\nimport { TexturePool } from '../../renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../../renderers/types.mjs';\n\n\"use strict\";\nconst tempBounds = new Bounds();\nclass AlphaMaskEffect extends FilterEffect {\n  constructor() {\n    super();\n    this.filters = [new MaskFilter({\n      sprite: new Sprite(Texture.EMPTY),\n      inverse: false,\n      resolution: \"inherit\",\n      antialias: \"inherit\"\n    })];\n  }\n  get sprite() {\n    return this.filters[0].sprite;\n  }\n  set sprite(value) {\n    this.filters[0].sprite = value;\n  }\n  get inverse() {\n    return this.filters[0].inverse;\n  }\n  set inverse(value) {\n    this.filters[0].inverse = value;\n  }\n}\nclass AlphaMaskPipe {\n  constructor(renderer) {\n    this._activeMaskStage = [];\n    this._renderer = renderer;\n  }\n  push(mask, maskedContainer, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"pushMaskBegin\",\n      mask,\n      inverse: maskedContainer._maskOptions.inverse,\n      canBundle: false,\n      maskedContainer\n    });\n    mask.inverse = maskedContainer._maskOptions.inverse;\n    if (mask.renderMaskToTexture) {\n      const maskContainer = mask.mask;\n      maskContainer.includeInBuild = true;\n      collectAllRenderables(\n        maskContainer,\n        instructionSet,\n        renderer\n      );\n      maskContainer.includeInBuild = false;\n    }\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"pushMaskEnd\",\n      mask,\n      maskedContainer,\n      inverse: maskedContainer._maskOptions.inverse,\n      canBundle: false\n    });\n  }\n  pop(mask, _maskedContainer, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"popMaskEnd\",\n      mask,\n      inverse: _maskedContainer._maskOptions.inverse,\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    const renderer = this._renderer;\n    const renderMask = instruction.mask.renderMaskToTexture;\n    if (instruction.action === \"pushMaskBegin\") {\n      const filterEffect = BigPool.get(AlphaMaskEffect);\n      filterEffect.inverse = instruction.inverse;\n      if (renderMask) {\n        instruction.mask.mask.measurable = true;\n        const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds);\n        instruction.mask.mask.measurable = false;\n        bounds.ceil();\n        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n        const filterTexture = TexturePool.getOptimalTexture(\n          bounds.width,\n          bounds.height,\n          colorTextureSource._resolution,\n          colorTextureSource.antialias\n        );\n        renderer.renderTarget.push(filterTexture, true);\n        renderer.globalUniforms.push({\n          offset: bounds,\n          worldColor: 4294967295\n        });\n        const sprite = filterEffect.sprite;\n        sprite.texture = filterTexture;\n        sprite.worldTransform.tx = bounds.minX;\n        sprite.worldTransform.ty = bounds.minY;\n        this._activeMaskStage.push({\n          filterEffect,\n          maskedContainer: instruction.maskedContainer,\n          filterTexture\n        });\n      } else {\n        filterEffect.sprite = instruction.mask.mask;\n        this._activeMaskStage.push({\n          filterEffect,\n          maskedContainer: instruction.maskedContainer\n        });\n      }\n    } else if (instruction.action === \"pushMaskEnd\") {\n      const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];\n      if (renderMask) {\n        if (renderer.type === RendererType.WEBGL) {\n          renderer.renderTarget.finishRenderPass();\n        }\n        renderer.renderTarget.pop();\n        renderer.globalUniforms.pop();\n      }\n      renderer.filter.push({\n        renderPipeId: \"filter\",\n        action: \"pushFilter\",\n        container: maskData.maskedContainer,\n        filterEffect: maskData.filterEffect,\n        canBundle: false\n      });\n    } else if (instruction.action === \"popMaskEnd\") {\n      renderer.filter.pop();\n      const maskData = this._activeMaskStage.pop();\n      if (renderMask) {\n        TexturePool.returnTexture(maskData.filterTexture);\n      }\n      BigPool.return(maskData.filterEffect);\n    }\n  }\n  destroy() {\n    this._renderer = null;\n    this._activeMaskStage = null;\n  }\n}\n/** @ignore */\nAlphaMaskPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"alphaMask\"\n};\n\nexport { AlphaMaskPipe };\n//# sourceMappingURL=AlphaMaskPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass ColorMaskPipe {\n  constructor(renderer) {\n    this._colorStack = [];\n    this._colorStackIndex = 0;\n    this._currentColor = 0;\n    this._renderer = renderer;\n  }\n  buildStart() {\n    this._colorStack[0] = 15;\n    this._colorStackIndex = 1;\n    this._currentColor = 15;\n  }\n  push(mask, _container, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    const colorStack = this._colorStack;\n    colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask.mask;\n    const currentColor = this._colorStack[this._colorStackIndex];\n    if (currentColor !== this._currentColor) {\n      this._currentColor = currentColor;\n      instructionSet.add({\n        renderPipeId: \"colorMask\",\n        colorMask: currentColor,\n        canBundle: false\n      });\n    }\n    this._colorStackIndex++;\n  }\n  pop(_mask, _container, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    const colorStack = this._colorStack;\n    this._colorStackIndex--;\n    const currentColor = colorStack[this._colorStackIndex - 1];\n    if (currentColor !== this._currentColor) {\n      this._currentColor = currentColor;\n      instructionSet.add({\n        renderPipeId: \"colorMask\",\n        colorMask: currentColor,\n        canBundle: false\n      });\n    }\n  }\n  execute(instruction) {\n    const renderer = this._renderer;\n    renderer.colorMask.setMask(instruction.colorMask);\n  }\n  destroy() {\n    this._colorStack = null;\n  }\n}\n/** @ignore */\nColorMaskPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"colorMask\"\n};\n\nexport { ColorMaskPipe };\n//# sourceMappingURL=ColorMaskPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { collectAllRenderables } from '../../../scene/container/utils/buildInstructions.mjs';\nimport { CLEAR } from '../../renderers/gl/const.mjs';\nimport { STENCIL_MODES } from '../../renderers/shared/state/const.mjs';\n\n\"use strict\";\nclass StencilMaskPipe {\n  constructor(renderer) {\n    // used when building and also when executing..\n    this._maskStackHash = {};\n    this._maskHash = /* @__PURE__ */ new WeakMap();\n    this._renderer = renderer;\n  }\n  push(mask, _container, instructionSet) {\n    var _a;\n    const effect = mask;\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    renderer.renderPipes.blendMode.setBlendMode(effect.mask, \"none\", instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"pushMaskBegin\",\n      mask,\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const maskContainer = effect.mask;\n    maskContainer.includeInBuild = true;\n    if (!this._maskHash.has(effect)) {\n      this._maskHash.set(effect, {\n        instructionsStart: 0,\n        instructionsLength: 0\n      });\n    }\n    const maskData = this._maskHash.get(effect);\n    maskData.instructionsStart = instructionSet.instructionSize;\n    collectAllRenderables(\n      maskContainer,\n      instructionSet,\n      renderer\n    );\n    maskContainer.includeInBuild = false;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"pushMaskEnd\",\n      mask,\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;\n    maskData.instructionsLength = instructionsLength;\n    const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n    (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);\n  }\n  pop(mask, _container, instructionSet) {\n    const effect = mask;\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    renderer.renderPipes.blendMode.setBlendMode(effect.mask, \"none\", instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"popMaskBegin\",\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const maskData = this._maskHash.get(mask);\n    for (let i = 0; i < maskData.instructionsLength; i++) {\n      instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];\n    }\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"popMaskEnd\",\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    var _a;\n    const renderer = this._renderer;\n    const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n    let maskStackIndex = (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);\n    if (instruction.action === \"pushMaskBegin\") {\n      renderer.renderTarget.ensureDepthStencil();\n      renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);\n      maskStackIndex++;\n      renderer.colorMask.setMask(0);\n    } else if (instruction.action === \"pushMaskEnd\") {\n      if (instruction.inverse) {\n        renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n      } else {\n        renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n      }\n      renderer.colorMask.setMask(15);\n    } else if (instruction.action === \"popMaskBegin\") {\n      renderer.colorMask.setMask(0);\n      if (maskStackIndex !== 0) {\n        renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);\n      } else {\n        renderer.renderTarget.clear(null, CLEAR.STENCIL);\n        renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);\n      }\n      maskStackIndex--;\n    } else if (instruction.action === \"popMaskEnd\") {\n      if (instruction.inverse) {\n        renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n      } else {\n        renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n      }\n      renderer.colorMask.setMask(15);\n    }\n    this._maskStackHash[renderTargetUid] = maskStackIndex;\n  }\n  destroy() {\n    this._renderer = null;\n    this._maskStackHash = null;\n    this._maskHash = null;\n  }\n}\nStencilMaskPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"stencilMask\"\n};\n\nexport { StencilMaskPipe };\n//# sourceMappingURL=StencilMaskPipe.mjs.map\n","import { warn } from '../../../../../utils/logging/warn.mjs';\nimport { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat.mjs';\n\n\"use strict\";\nfunction ensureAttributes(geometry, extractedData) {\n  for (const i in geometry.attributes) {\n    const attribute = geometry.attributes[i];\n    const attributeData = extractedData[i];\n    if (attributeData) {\n      attribute.format ?? (attribute.format = attributeData.format);\n      attribute.offset ?? (attribute.offset = attributeData.offset);\n      attribute.instance ?? (attribute.instance = attributeData.instance);\n    } else {\n      warn(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);\n    }\n  }\n  ensureStartAndStride(geometry);\n}\nfunction ensureStartAndStride(geometry) {\n  const { buffers, attributes } = geometry;\n  const tempStride = {};\n  const tempStart = {};\n  for (const j in buffers) {\n    const buffer = buffers[j];\n    tempStride[buffer.uid] = 0;\n    tempStart[buffer.uid] = 0;\n  }\n  for (const j in attributes) {\n    const attribute = attributes[j];\n    tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n  }\n  for (const j in attributes) {\n    const attribute = attributes[j];\n    attribute.stride ?? (attribute.stride = tempStride[attribute.buffer.uid]);\n    attribute.start ?? (attribute.start = tempStart[attribute.buffer.uid]);\n    tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n  }\n}\n\nexport { ensureAttributes };\n//# sourceMappingURL=ensureAttributes.mjs.map\n","import { STENCIL_MODES } from '../../shared/state/const.mjs';\n\n\"use strict\";\nconst GpuStencilModesToPixi = [];\nGpuStencilModesToPixi[STENCIL_MODES.NONE] = void 0;\nGpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {\n  stencilWriteMask: 0,\n  stencilReadMask: 0\n};\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"increment-clamp\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"increment-clamp\"\n  }\n};\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"decrement-clamp\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"decrement-clamp\"\n  }\n};\nGpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {\n  stencilWriteMask: 0,\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"keep\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"keep\"\n  }\n};\nGpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE] = {\n  stencilWriteMask: 0,\n  stencilFront: {\n    compare: \"not-equal\",\n    passOp: \"replace\"\n  },\n  stencilBack: {\n    compare: \"not-equal\",\n    passOp: \"replace\"\n  }\n};\n\nexport { GpuStencilModesToPixi };\n//# sourceMappingURL=GpuStencilModesToPixi.mjs.map\n","import { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported.mjs';\nimport { Buffer } from '../buffer/Buffer.mjs';\nimport { BufferUsage } from '../buffer/const.mjs';\n\n\"use strict\";\nclass UboSystem {\n  constructor(adaptor) {\n    /** Cache of uniform buffer layouts and sync functions, so we don't have to re-create them */\n    this._syncFunctionHash = /* @__PURE__ */ Object.create(null);\n    this._adaptor = adaptor;\n    this._systemCheck();\n  }\n  /**\n   * Overridable function by `pixi.js/unsafe-eval` to silence\n   * throwing an error if platform doesn't support unsafe-evals.\n   * @private\n   */\n  _systemCheck() {\n    if (!unsafeEvalSupported()) {\n      throw new Error(\"Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.\");\n    }\n  }\n  ensureUniformGroup(uniformGroup) {\n    const uniformData = this.getUniformGroupData(uniformGroup);\n    uniformGroup.buffer || (uniformGroup.buffer = new Buffer({\n      data: new Float32Array(uniformData.layout.size / 4),\n      usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST\n    }));\n  }\n  getUniformGroupData(uniformGroup) {\n    return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);\n  }\n  _initUniformGroup(uniformGroup) {\n    const uniformGroupSignature = uniformGroup._signature;\n    let uniformData = this._syncFunctionHash[uniformGroupSignature];\n    if (!uniformData) {\n      const elements = Object.keys(uniformGroup.uniformStructures).map((i) => uniformGroup.uniformStructures[i]);\n      const layout = this._adaptor.createUboElements(elements);\n      const syncFunction = this._generateUboSync(layout.uboElements);\n      uniformData = this._syncFunctionHash[uniformGroupSignature] = {\n        layout,\n        syncFunction\n      };\n    }\n    return this._syncFunctionHash[uniformGroupSignature];\n  }\n  _generateUboSync(uboElements) {\n    return this._adaptor.generateUboSync(uboElements);\n  }\n  syncUniformGroup(uniformGroup, data, offset) {\n    const uniformGroupData = this.getUniformGroupData(uniformGroup);\n    uniformGroup.buffer || (uniformGroup.buffer = new Buffer({\n      data: new Float32Array(uniformGroupData.layout.size / 4),\n      usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST\n    }));\n    data || (data = uniformGroup.buffer.data);\n    offset || (offset = 0);\n    uniformGroupData.syncFunction(uniformGroup.uniforms, data, offset);\n    return true;\n  }\n  updateUniformGroup(uniformGroup) {\n    if (uniformGroup.isStatic && !uniformGroup._dirtyId)\n      return false;\n    uniformGroup._dirtyId = 0;\n    const synced = this.syncUniformGroup(uniformGroup);\n    uniformGroup.buffer.update();\n    return synced;\n  }\n  destroy() {\n    this._syncFunctionHash = null;\n  }\n}\n\nexport { UboSystem };\n//# sourceMappingURL=UboSystem.mjs.map\n","\"use strict\";\nconst uniformParsers = [\n  // uploading pixi matrix object to mat3\n  {\n    type: \"mat3x3<f32>\",\n    test: (data) => {\n      const value = data.value;\n      return value.a !== void 0;\n    },\n    ubo: `\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        `,\n    uniform: `\n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        `\n  },\n  // uploading a pixi rectangle as a vec4\n  {\n    type: \"vec4<f32>\",\n    test: (data) => data.type === \"vec4<f32>\" && data.size === 1 && data.value.width !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        `\n  },\n  // uploading a pixi point as a vec2\n  {\n    type: \"vec2<f32>\",\n    test: (data) => data.type === \"vec2<f32>\" && data.size === 1 && data.value.x !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        `\n  },\n  // uploading a pixi color as a vec4\n  {\n    type: \"vec4<f32>\",\n    test: (data) => data.type === \"vec4<f32>\" && data.size === 1 && data.value.red !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        `\n  },\n  // uploading a pixi color as a vec3\n  {\n    type: \"vec3<f32>\",\n    test: (data) => data.type === \"vec3<f32>\" && data.size === 1 && data.value.red !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        `\n  }\n];\n\nexport { uniformParsers };\n//# sourceMappingURL=uniformParsers.mjs.map\n","import { uniformParsers } from './uniformParsers.mjs';\n\n\"use strict\";\nfunction createUboSyncFunction(uboElements, parserCode, arrayGenerationFunction, singleSettersMap) {\n  const funcFragments = [`\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    `];\n  let prev = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    const name = uboElement.data.name;\n    let parsed = false;\n    let offset = 0;\n    for (let j = 0; j < uniformParsers.length; j++) {\n      const uniformParser = uniformParsers[j];\n      if (uniformParser.test(uboElement.data)) {\n        offset = uboElement.offset / 4;\n        funcFragments.push(\n          `name = \"${name}\";`,\n          `offset += ${offset - prev};`,\n          uniformParsers[j][parserCode] || uniformParsers[j].ubo\n        );\n        parsed = true;\n        break;\n      }\n    }\n    if (!parsed) {\n      if (uboElement.data.size > 1) {\n        offset = uboElement.offset / 4;\n        funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));\n      } else {\n        const template = singleSettersMap[uboElement.data.type];\n        offset = uboElement.offset / 4;\n        funcFragments.push(\n          /* wgsl */\n          `\n                    v = uv.${name};\n                    offset += ${offset - prev};\n                    ${template};\n                `\n        );\n      }\n    }\n    prev = offset;\n  }\n  const fragmentSrc = funcFragments.join(\"\\n\");\n  return new Function(\n    \"uv\",\n    \"data\",\n    \"offset\",\n    fragmentSrc\n  );\n}\n\nexport { createUboSyncFunction };\n//# sourceMappingURL=createUboSyncFunction.mjs.map\n","\"use strict\";\nfunction loopMatrix(col, row) {\n  const total = col * row;\n  return `\n        for (let i = 0; i < ${total}; i++) {\n            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];\n        }\n    `;\n}\nconst uboSyncFunctionsSTD40 = {\n  f32: `\n        data[offset] = v;`,\n  i32: `\n        data[offset] = v;`,\n  \"vec2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];`,\n  \"vec3<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];`,\n  \"vec4<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];`,\n  \"mat2x2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];`,\n  \"mat3x3<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];`,\n  \"mat4x4<f32>\": `\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }`,\n  \"mat3x2<f32>\": loopMatrix(3, 2),\n  \"mat4x2<f32>\": loopMatrix(4, 2),\n  \"mat2x3<f32>\": loopMatrix(2, 3),\n  \"mat4x3<f32>\": loopMatrix(4, 3),\n  \"mat2x4<f32>\": loopMatrix(2, 4),\n  \"mat3x4<f32>\": loopMatrix(3, 4)\n};\nconst uboSyncFunctionsWGSL = {\n  ...uboSyncFunctionsSTD40,\n  \"mat2x2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    `\n};\n\nexport { uboSyncFunctionsSTD40, uboSyncFunctionsWGSL };\n//# sourceMappingURL=uboSyncFunctions.mjs.map\n","\"use strict\";\nfunction calculateProjection(pm, x, y, width, height, flipY) {\n  const sign = flipY ? 1 : -1;\n  pm.identity();\n  pm.a = 1 / width * 2;\n  pm.d = sign * (1 / height * 2);\n  pm.tx = -1 - x * pm.a;\n  pm.ty = -sign - y * pm.d;\n  return pm;\n}\n\nexport { calculateProjection };\n//# sourceMappingURL=calculateProjection.mjs.map\n","import { CanvasSource } from '../sources/CanvasSource.mjs';\nimport { Texture } from '../Texture.mjs';\n\n\"use strict\";\nconst canvasCache = /* @__PURE__ */ new Map();\nfunction getCanvasTexture(canvas, options) {\n  if (!canvasCache.has(canvas)) {\n    const texture = new Texture({\n      source: new CanvasSource({\n        resource: canvas,\n        ...options\n      })\n    });\n    const onDestroy = () => {\n      if (canvasCache.get(canvas) === texture) {\n        canvasCache.delete(canvas);\n      }\n    };\n    texture.once(\"destroy\", onDestroy);\n    texture.source.once(\"destroy\", onDestroy);\n    canvasCache.set(canvas, texture);\n  }\n  return canvasCache.get(canvas);\n}\nfunction hasCachedCanvasTexture(canvas) {\n  return canvasCache.has(canvas);\n}\n\nexport { getCanvasTexture, hasCachedCanvasTexture };\n//# sourceMappingURL=getCanvasTexture.mjs.map\n","\"use strict\";\nfunction isRenderingToScreen(renderTarget) {\n  const resource = renderTarget.colorTexture.source.resource;\n  return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement && document.body.contains(resource);\n}\n\nexport { isRenderingToScreen };\n//# sourceMappingURL=isRenderingToScreen.mjs.map\n","import { uid } from '../../../../utils/data/uid.mjs';\nimport { TextureSource } from '../texture/sources/TextureSource.mjs';\nimport { Texture } from '../texture/Texture.mjs';\n\n\"use strict\";\nconst _RenderTarget = class _RenderTarget {\n  /**\n   * @param [descriptor] - Options for creating a render target.\n   */\n  constructor(descriptor = {}) {\n    /** unique id for this render target */\n    this.uid = uid(\"renderTarget\");\n    /**\n     * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could\n     * write to multiple if required! (eg deferred lighting)\n     */\n    this.colorTextures = [];\n    this.dirtyId = 0;\n    this.isRoot = false;\n    this._size = new Float32Array(2);\n    /** if true, then when the render target is destroyed, it will destroy all the textures that were created for it. */\n    this._managedColorTextures = false;\n    descriptor = { ..._RenderTarget.defaultOptions, ...descriptor };\n    this.stencil = descriptor.stencil;\n    this.depth = descriptor.depth;\n    this.isRoot = descriptor.isRoot;\n    if (typeof descriptor.colorTextures === \"number\") {\n      this._managedColorTextures = true;\n      for (let i = 0; i < descriptor.colorTextures; i++) {\n        this.colorTextures.push(\n          new TextureSource({\n            width: descriptor.width,\n            height: descriptor.height,\n            resolution: descriptor.resolution,\n            antialias: descriptor.antialias\n          })\n        );\n      }\n    } else {\n      this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];\n      const colorSource = this.colorTexture.source;\n      this.resize(colorSource.width, colorSource.height, colorSource._resolution);\n    }\n    this.colorTexture.source.on(\"resize\", this.onSourceResize, this);\n    if (descriptor.depthStencilTexture || this.stencil) {\n      if (descriptor.depthStencilTexture instanceof Texture || descriptor.depthStencilTexture instanceof TextureSource) {\n        this.depthStencilTexture = descriptor.depthStencilTexture.source;\n      } else {\n        this.ensureDepthStencilTexture();\n      }\n    }\n  }\n  get size() {\n    const _size = this._size;\n    _size[0] = this.pixelWidth;\n    _size[1] = this.pixelHeight;\n    return _size;\n  }\n  get width() {\n    return this.colorTexture.source.width;\n  }\n  get height() {\n    return this.colorTexture.source.height;\n  }\n  get pixelWidth() {\n    return this.colorTexture.source.pixelWidth;\n  }\n  get pixelHeight() {\n    return this.colorTexture.source.pixelHeight;\n  }\n  get resolution() {\n    return this.colorTexture.source._resolution;\n  }\n  get colorTexture() {\n    return this.colorTextures[0];\n  }\n  onSourceResize(source) {\n    this.resize(source.width, source.height, source._resolution, true);\n  }\n  /**\n   * This will ensure a depthStencil texture is created for this render target.\n   * Most likely called by the mask system to make sure we have stencil buffer added.\n   * @internal\n   * @ignore\n   */\n  ensureDepthStencilTexture() {\n    if (!this.depthStencilTexture) {\n      this.depthStencilTexture = new TextureSource({\n        width: this.width,\n        height: this.height,\n        resolution: this.resolution,\n        format: \"depth24plus-stencil8\",\n        autoGenerateMipmaps: false,\n        antialias: false,\n        mipLevelCount: 1\n        // sampleCount: handled by the render target system..\n      });\n    }\n  }\n  resize(width, height, resolution = this.resolution, skipColorTexture = false) {\n    this.dirtyId++;\n    this.colorTextures.forEach((colorTexture, i) => {\n      if (skipColorTexture && i === 0)\n        return;\n      colorTexture.source.resize(width, height, resolution);\n    });\n    if (this.depthStencilTexture) {\n      this.depthStencilTexture.source.resize(width, height, resolution);\n    }\n  }\n  destroy() {\n    this.colorTexture.source.off(\"resize\", this.onSourceResize, this);\n    if (this._managedColorTextures) {\n      this.colorTextures.forEach((texture) => {\n        texture.destroy();\n      });\n    }\n    if (this.depthStencilTexture) {\n      this.depthStencilTexture.destroy();\n      delete this.depthStencilTexture;\n    }\n  }\n};\n/** The default options for a render target */\n_RenderTarget.defaultOptions = {\n  /** the width of the RenderTarget */\n  width: 0,\n  /** the height of the RenderTarget */\n  height: 0,\n  /** the resolution of the RenderTarget */\n  resolution: 1,\n  /** an array of textures, or a number indicating how many color textures there should be */\n  colorTextures: 1,\n  /** should this render target have a stencil buffer? */\n  stencil: false,\n  /** should this render target have a depth buffer? */\n  depth: false,\n  /** should this render target be antialiased? */\n  antialias: false,\n  // save on perf by default!\n  /** is this a root element, true if this is gl context owners render target */\n  isRoot: false\n};\nlet RenderTarget = _RenderTarget;\n\nexport { RenderTarget };\n//# sourceMappingURL=RenderTarget.mjs.map\n","import { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { CLEAR } from '../../gl/const.mjs';\nimport { calculateProjection } from '../../gpu/renderTarget/calculateProjection.mjs';\nimport { SystemRunner } from '../system/SystemRunner.mjs';\nimport { CanvasSource } from '../texture/sources/CanvasSource.mjs';\nimport { TextureSource } from '../texture/sources/TextureSource.mjs';\nimport { Texture } from '../texture/Texture.mjs';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture.mjs';\nimport { isRenderingToScreen } from './isRenderingToScreen.mjs';\nimport { RenderTarget } from './RenderTarget.mjs';\n\n\"use strict\";\nclass RenderTargetSystem {\n  constructor(renderer) {\n    /** This is the root viewport for the render pass*/\n    this.rootViewPort = new Rectangle();\n    /** the current viewport that the gpu is using */\n    this.viewport = new Rectangle();\n    /**\n     * a runner that lets systems know if the active render target has changed.\n     * Eg the Stencil System needs to know so it can manage the stencil buffer\n     */\n    this.onRenderTargetChange = new SystemRunner(\"onRenderTargetChange\");\n    /** the projection matrix that is used by the shaders based on the active render target and the viewport */\n    this.projectionMatrix = new Matrix();\n    /** the default clear color for render targets */\n    this.defaultClearColor = [0, 0, 0, 0];\n    /**\n     * a hash that stores the render target for a given render surface. When you pass in a texture source,\n     * a render target is created for it. This map stores and makes it easy to retrieve the render target\n     */\n    this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();\n    /** A hash that stores a gpu render target for a given render target. */\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n    /**\n     * A stack that stores the render target and frame that is currently being rendered to.\n     * When push is called, the current render target is stored in this stack.\n     * When pop is called, the previous render target is restored.\n     */\n    this._renderTargetStack = [];\n    this._renderer = renderer;\n    renderer.renderableGC.addManagedHash(this, \"_gpuRenderTargetHash\");\n  }\n  /** called when dev wants to finish a render pass */\n  finishRenderPass() {\n    this.adaptor.finishRenderPass(this.renderTarget);\n  }\n  /**\n   * called when the renderer starts to render a scene.\n   * @param options\n   * @param options.target - the render target to render to\n   * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param options.clearColor - the color to clear to\n   * @param options.frame - the frame to render to\n   */\n  renderStart({\n    target,\n    clear,\n    clearColor,\n    frame\n  }) {\n    this._renderTargetStack.length = 0;\n    this.push(\n      target,\n      clear,\n      clearColor,\n      frame\n    );\n    this.rootViewPort.copyFrom(this.viewport);\n    this.rootRenderTarget = this.renderTarget;\n    this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);\n  }\n  postrender() {\n    this.adaptor.postrender?.(this.rootRenderTarget);\n  }\n  /**\n   * Binding a render surface! This is the main function of the render target system.\n   * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.\n   * Once bound all draw calls will be rendered to the render surface.\n   *\n   * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.\n   * @param renderSurface - the render surface to bind\n   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param clearColor - the color to clear to\n   * @param frame - the frame to render to\n   * @returns the render target that was bound\n   */\n  bind(renderSurface, clear = true, clearColor, frame) {\n    const renderTarget = this.getRenderTarget(renderSurface);\n    const didChange = this.renderTarget !== renderTarget;\n    this.renderTarget = renderTarget;\n    this.renderSurface = renderSurface;\n    const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);\n    if (renderTarget.pixelWidth !== gpuRenderTarget.width || renderTarget.pixelHeight !== gpuRenderTarget.height) {\n      this.adaptor.resizeGpuRenderTarget(renderTarget);\n      gpuRenderTarget.width = renderTarget.pixelWidth;\n      gpuRenderTarget.height = renderTarget.pixelHeight;\n    }\n    const source = renderTarget.colorTexture;\n    const viewport = this.viewport;\n    const pixelWidth = source.pixelWidth;\n    const pixelHeight = source.pixelHeight;\n    if (!frame && renderSurface instanceof Texture) {\n      frame = renderSurface.frame;\n    }\n    if (frame) {\n      const resolution = source._resolution;\n      viewport.x = frame.x * resolution + 0.5 | 0;\n      viewport.y = frame.y * resolution + 0.5 | 0;\n      viewport.width = frame.width * resolution + 0.5 | 0;\n      viewport.height = frame.height * resolution + 0.5 | 0;\n    } else {\n      viewport.x = 0;\n      viewport.y = 0;\n      viewport.width = pixelWidth;\n      viewport.height = pixelHeight;\n    }\n    calculateProjection(\n      this.projectionMatrix,\n      0,\n      0,\n      viewport.width / source.resolution,\n      viewport.height / source.resolution,\n      !renderTarget.isRoot\n    );\n    this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);\n    if (didChange) {\n      this.onRenderTargetChange.emit(renderTarget);\n    }\n    return renderTarget;\n  }\n  clear(target, clear = CLEAR.ALL, clearColor) {\n    if (!clear)\n      return;\n    if (target) {\n      target = this.getRenderTarget(target);\n    }\n    this.adaptor.clear(\n      target || this.renderTarget,\n      clear,\n      clearColor,\n      this.viewport\n    );\n  }\n  contextChange() {\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n  }\n  /**\n   * Push a render surface to the renderer. This will bind the render surface to the renderer,\n   * @param renderSurface - the render surface to push\n   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param clearColor - the color to clear to\n   * @param frame - the frame to use when rendering to the render surface\n   */\n  push(renderSurface, clear = CLEAR.ALL, clearColor, frame) {\n    const renderTarget = this.bind(renderSurface, clear, clearColor, frame);\n    this._renderTargetStack.push({\n      renderTarget,\n      frame\n    });\n    return renderTarget;\n  }\n  /** Pops the current render target from the renderer and restores the previous render target. */\n  pop() {\n    this._renderTargetStack.pop();\n    const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];\n    this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);\n  }\n  /**\n   * Gets the render target from the provide render surface. Eg if its a texture,\n   * it will return the render target for the texture.\n   * If its a render target, it will return the same render target.\n   * @param renderSurface - the render surface to get the render target for\n   * @returns the render target for the render surface\n   */\n  getRenderTarget(renderSurface) {\n    if (renderSurface.isTexture) {\n      renderSurface = renderSurface.source;\n    }\n    return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);\n  }\n  /**\n   * Copies a render surface to another texture\n   * @param sourceRenderSurfaceTexture - the render surface to copy from\n   * @param destinationTexture - the texture to copy to\n   * @param originSrc - the origin of the copy\n   * @param originSrc.x - the x origin of the copy\n   * @param originSrc.y - the y origin of the copy\n   * @param size - the size of the copy\n   * @param size.width - the width of the copy\n   * @param size.height - the height of the copy\n   * @param originDest - the destination origin (top left to paste from!)\n   * @param originDest.x - the x origin of the paste\n   * @param originDest.y - the y origin of the paste\n   */\n  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n    if (originSrc.x < 0) {\n      size.width += originSrc.x;\n      originDest.x -= originSrc.x;\n      originSrc.x = 0;\n    }\n    if (originSrc.y < 0) {\n      size.height += originSrc.y;\n      originDest.y -= originSrc.y;\n      originSrc.y = 0;\n    }\n    const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;\n    size.width = Math.min(size.width, pixelWidth - originSrc.x);\n    size.height = Math.min(size.height, pixelHeight - originSrc.y);\n    return this.adaptor.copyToTexture(\n      sourceRenderSurfaceTexture,\n      destinationTexture,\n      originSrc,\n      size,\n      originDest\n    );\n  }\n  /**\n   * ensures that we have a depth stencil buffer available to render to\n   * This is used by the mask system to make sure we have a stencil buffer.\n   */\n  ensureDepthStencil() {\n    if (!this.renderTarget.stencil) {\n      this.renderTarget.stencil = true;\n      this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);\n    }\n  }\n  /** nukes the render target system */\n  destroy() {\n    this._renderer = null;\n    this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) => {\n      if (renderTarget !== key) {\n        renderTarget.destroy();\n      }\n    });\n    this._renderSurfaceToRenderTargetHash.clear();\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n  }\n  _initRenderTarget(renderSurface) {\n    let renderTarget = null;\n    if (CanvasSource.test(renderSurface)) {\n      renderSurface = getCanvasTexture(renderSurface).source;\n    }\n    if (renderSurface instanceof RenderTarget) {\n      renderTarget = renderSurface;\n    } else if (renderSurface instanceof TextureSource) {\n      renderTarget = new RenderTarget({\n        colorTextures: [renderSurface]\n      });\n      if (CanvasSource.test(renderSurface.source.resource)) {\n        renderTarget.isRoot = true;\n      }\n      renderSurface.once(\"destroy\", () => {\n        renderTarget.destroy();\n        this._renderSurfaceToRenderTargetHash.delete(renderSurface);\n        const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];\n        if (gpuRenderTarget) {\n          this._gpuRenderTargetHash[renderTarget.uid] = null;\n          this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);\n        }\n      });\n    }\n    this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);\n    return renderTarget;\n  }\n  getGpuRenderTarget(renderTarget) {\n    return this._gpuRenderTargetHash[renderTarget.uid] || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));\n  }\n}\n\nexport { RenderTargetSystem };\n//# sourceMappingURL=RenderTargetSystem.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid.mjs';\n\n\"use strict\";\nclass BufferResource extends EventEmitter {\n  /**\n   * Create a new Buffer Resource.\n   * @param options - The options for the buffer resource\n   * @param options.buffer - The underlying buffer that this resource is using\n   * @param options.offset - The offset of the buffer this resource is using.\n   * If not provided, then it will use the offset of the buffer.\n   * @param options.size - The size of the buffer this resource is using.\n   * If not provided, then it will use the size of the buffer.\n   */\n  constructor({ buffer, offset, size }) {\n    super();\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n    /** a unique id for this uniform group used through the renderer */\n    this.uid = uid(\"buffer\");\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    this._resourceType = \"bufferResource\";\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    this._touched = 0;\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    this._resourceId = uid(\"resource\");\n    /**\n     * A cheeky hint to the GL renderer to let it know this is a BufferResource\n     * @internal\n     * @ignore\n     */\n    this._bufferResource = true;\n    /**\n     * Has the Buffer resource been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    this.buffer = buffer;\n    this.offset = offset | 0;\n    this.size = size;\n    this.buffer.on(\"change\", this.onBufferChange, this);\n  }\n  onBufferChange() {\n    this._resourceId = uid(\"resource\");\n    this.emit(\"change\", this);\n  }\n  /**\n   * Destroys this resource. Make sure the underlying buffer is not used anywhere else\n   * if you want to destroy it as well, or code will explode\n   * @param destroyBuffer - Should the underlying buffer be destroyed as well?\n   */\n  destroy(destroyBuffer = false) {\n    this.destroyed = true;\n    if (destroyBuffer) {\n      this.buffer.destroy();\n    }\n    this.emit(\"change\", this);\n    this.buffer = null;\n  }\n}\n\nexport { BufferResource };\n//# sourceMappingURL=BufferResource.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass CustomRenderPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  updateRenderable() {\n  }\n  destroyRenderable() {\n  }\n  validateRenderable() {\n    return false;\n  }\n  addRenderable(container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add(container);\n  }\n  execute(container) {\n    if (!container.isRenderable)\n      return;\n    container.render(this._renderer);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\nCustomRenderPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"customRender\"\n};\n\nexport { CustomRenderPipe };\n//# sourceMappingURL=CustomRenderPipe.mjs.map\n","\"use strict\";\nfunction executeInstructions(renderGroup, renderer) {\n  const instructionSet = renderGroup.instructionSet;\n  const instructions = instructionSet.instructions;\n  for (let i = 0; i < instructionSet.instructionSize; i++) {\n    const instruction = instructions[i];\n    renderer[instruction.renderPipeId].execute(instruction);\n  }\n}\n\nexport { executeInstructions };\n//# sourceMappingURL=executeInstructions.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { executeInstructions } from './utils/executeInstructions.mjs';\n\n\"use strict\";\nclass RenderGroupPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  addRenderGroup(renderGroup, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add(renderGroup);\n  }\n  execute(renderGroup) {\n    if (!renderGroup.isRenderable)\n      return;\n    this._renderer.globalUniforms.push({\n      worldTransformMatrix: renderGroup.worldTransform,\n      worldColor: renderGroup.worldColorAlpha\n    });\n    executeInstructions(renderGroup, this._renderer.renderPipes);\n    this._renderer.globalUniforms.pop();\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\nRenderGroupPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"renderGroup\"\n};\n\nexport { RenderGroupPipe };\n//# sourceMappingURL=RenderGroupPipe.mjs.map\n","\"use strict\";\nfunction clearList(list, index) {\n  index || (index = 0);\n  for (let j = index; j < list.length; j++) {\n    if (list[j]) {\n      list[j] = null;\n    } else {\n      break;\n    }\n  }\n}\n\nexport { clearList };\n//# sourceMappingURL=clearList.mjs.map\n","\"use strict\";\nfunction collectRenderGroups(renderGroup, out = []) {\n  out.push(renderGroup);\n  for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {\n    collectRenderGroups(renderGroup.renderGroupChildren[i], out);\n  }\n  return out;\n}\n\nexport { collectRenderGroups };\n//# sourceMappingURL=collectRenderGroups.mjs.map\n","\"use strict\";\nfunction mixHexColors(color1, color2, ratio) {\n  const r1 = color1 >> 16 & 255;\n  const g1 = color1 >> 8 & 255;\n  const b1 = color1 & 255;\n  const r2 = color2 >> 16 & 255;\n  const g2 = color2 >> 8 & 255;\n  const b2 = color2 & 255;\n  const r = r1 + (r2 - r1) * ratio;\n  const g = g1 + (g2 - g1) * ratio;\n  const b = b1 + (b2 - b1) * ratio;\n  return (r << 16) + (g << 8) + b;\n}\n\nexport { mixHexColors };\n//# sourceMappingURL=mixHexColors.mjs.map\n","import { mixHexColors } from './mixHexColors.mjs';\n\n\"use strict\";\nconst WHITE_BGR = 16777215;\nfunction mixColors(localBGRColor, parentBGRColor) {\n  if (localBGRColor === WHITE_BGR || parentBGRColor === WHITE_BGR) {\n    return localBGRColor + parentBGRColor - WHITE_BGR;\n  }\n  return mixHexColors(localBGRColor, parentBGRColor, 0.5);\n}\nfunction mixStandardAnd32BitColors(localColorRGB, localAlpha, parentColor) {\n  const parentAlpha = (parentColor >> 24 & 255) / 255;\n  const globalAlpha = localAlpha * parentAlpha * 255;\n  const localBGRColor = ((localColorRGB & 255) << 16) + (localColorRGB & 65280) + (localColorRGB >> 16 & 255);\n  const parentBGRColor = parentColor & 16777215;\n  let sharedBGRColor;\n  if (localBGRColor === WHITE_BGR || parentBGRColor === WHITE_BGR) {\n    sharedBGRColor = localBGRColor + parentBGRColor - WHITE_BGR;\n  } else {\n    sharedBGRColor = mixHexColors(localBGRColor, parentBGRColor, 0.5);\n  }\n  return sharedBGRColor + (globalAlpha << 24);\n}\n\nexport { mixColors, mixStandardAnd32BitColors };\n//# sourceMappingURL=mixColors.mjs.map\n","import { Container, UPDATE_VISIBLE, UPDATE_COLOR, UPDATE_BLEND } from '../Container.mjs';\nimport { clearList } from './clearList.mjs';\nimport { mixColors } from './mixColors.mjs';\n\n\"use strict\";\nconst tempContainer = new Container();\nconst UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;\nfunction updateRenderGroupTransforms(renderGroup, updateChildRenderGroups = false) {\n  updateRenderGroupTransform(renderGroup);\n  const childrenToUpdate = renderGroup.childrenToUpdate;\n  const updateTick = renderGroup.updateTick++;\n  for (const j in childrenToUpdate) {\n    const renderGroupDepth = Number(j);\n    const childrenAtDepth = childrenToUpdate[j];\n    const list = childrenAtDepth.list;\n    const index = childrenAtDepth.index;\n    for (let i = 0; i < index; i++) {\n      const child = list[i];\n      if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth) {\n        updateTransformAndChildren(child, updateTick, 0);\n      }\n    }\n    clearList(list, index);\n    childrenAtDepth.index = 0;\n  }\n  if (updateChildRenderGroups) {\n    for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {\n      updateRenderGroupTransforms(renderGroup.renderGroupChildren[i], updateChildRenderGroups);\n    }\n  }\n}\nfunction updateRenderGroupTransform(renderGroup) {\n  const root = renderGroup.root;\n  let worldAlpha;\n  if (renderGroup.renderGroupParent) {\n    const renderGroupParent = renderGroup.renderGroupParent;\n    renderGroup.worldTransform.appendFrom(\n      root.relativeGroupTransform,\n      renderGroupParent.worldTransform\n    );\n    renderGroup.worldColor = mixColors(\n      root.groupColor,\n      renderGroupParent.worldColor\n    );\n    worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;\n  } else {\n    renderGroup.worldTransform.copyFrom(root.localTransform);\n    renderGroup.worldColor = root.localColor;\n    worldAlpha = root.localAlpha;\n  }\n  worldAlpha = worldAlpha < 0 ? 0 : worldAlpha > 1 ? 1 : worldAlpha;\n  renderGroup.worldAlpha = worldAlpha;\n  renderGroup.worldColorAlpha = renderGroup.worldColor + ((worldAlpha * 255 | 0) << 24);\n}\nfunction updateTransformAndChildren(container, updateTick, updateFlags) {\n  if (updateTick === container.updateTick)\n    return;\n  container.updateTick = updateTick;\n  container.didChange = false;\n  const localTransform = container.localTransform;\n  container.updateLocalTransform();\n  const parent = container.parent;\n  if (parent && !parent.renderGroup) {\n    updateFlags = updateFlags | container._updateFlags;\n    container.relativeGroupTransform.appendFrom(\n      localTransform,\n      parent.relativeGroupTransform\n    );\n    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {\n      updateColorBlendVisibility(container, parent, updateFlags);\n    }\n  } else {\n    updateFlags = container._updateFlags;\n    container.relativeGroupTransform.copyFrom(localTransform);\n    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {\n      updateColorBlendVisibility(container, tempContainer, updateFlags);\n    }\n  }\n  if (!container.renderGroup) {\n    const children = container.children;\n    const length = children.length;\n    for (let i = 0; i < length; i++) {\n      updateTransformAndChildren(children[i], updateTick, updateFlags);\n    }\n    const renderGroup = container.parentRenderGroup;\n    const renderable = container;\n    if (renderable.renderPipeId && !renderGroup.structureDidChange) {\n      renderGroup.updateRenderable(renderable);\n    }\n  }\n}\nfunction updateColorBlendVisibility(container, parent, updateFlags) {\n  if (updateFlags & UPDATE_COLOR) {\n    container.groupColor = mixColors(\n      container.localColor,\n      parent.groupColor\n    );\n    let groupAlpha = container.localAlpha * parent.groupAlpha;\n    groupAlpha = groupAlpha < 0 ? 0 : groupAlpha > 1 ? 1 : groupAlpha;\n    container.groupAlpha = groupAlpha;\n    container.groupColorAlpha = container.groupColor + ((groupAlpha * 255 | 0) << 24);\n  }\n  if (updateFlags & UPDATE_BLEND) {\n    container.groupBlendMode = container.localBlendMode === \"inherit\" ? parent.groupBlendMode : container.localBlendMode;\n  }\n  if (updateFlags & UPDATE_VISIBLE) {\n    container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;\n  }\n  container._updateFlags = 0;\n}\n\nexport { updateRenderGroupTransform, updateRenderGroupTransforms, updateTransformAndChildren };\n//# sourceMappingURL=updateRenderGroupTransforms.mjs.map\n","\"use strict\";\nfunction validateRenderables(renderGroup, renderPipes) {\n  const { list, index } = renderGroup.childrenRenderablesToUpdate;\n  let rebuildRequired = false;\n  for (let i = 0; i < index; i++) {\n    const container = list[i];\n    const renderable = container;\n    const pipe = renderPipes[renderable.renderPipeId];\n    rebuildRequired = pipe.validateRenderable(container);\n    if (rebuildRequired) {\n      break;\n    }\n  }\n  renderGroup.structureDidChange = rebuildRequired;\n  return rebuildRequired;\n}\n\nexport { validateRenderables };\n//# sourceMappingURL=validateRenderables.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { buildInstructions } from './utils/buildInstructions.mjs';\nimport { clearList } from './utils/clearList.mjs';\nimport { collectRenderGroups } from './utils/collectRenderGroups.mjs';\nimport { executeInstructions } from './utils/executeInstructions.mjs';\nimport { updateRenderGroupTransforms } from './utils/updateRenderGroupTransforms.mjs';\nimport { validateRenderables } from './utils/validateRenderables.mjs';\n\n\"use strict\";\nconst tempMatrix = new Matrix();\nclass RenderGroupSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  render({ container, transform }) {\n    container.isRenderGroup = true;\n    const parent = container.parent;\n    const renderGroupParent = container.renderGroup.renderGroupParent;\n    container.parent = null;\n    container.renderGroup.renderGroupParent = null;\n    const renderer = this._renderer;\n    const renderGroups = collectRenderGroups(container.renderGroup, []);\n    let originalLocalTransform = tempMatrix;\n    if (transform) {\n      originalLocalTransform = originalLocalTransform.copyFrom(container.renderGroup.localTransform);\n      container.renderGroup.localTransform.copyFrom(transform);\n    }\n    const renderPipes = renderer.renderPipes;\n    for (let i = 0; i < renderGroups.length; i++) {\n      const renderGroup = renderGroups[i];\n      renderGroup.runOnRender();\n      renderGroup.instructionSet.renderPipes = renderPipes;\n      if (!renderGroup.structureDidChange) {\n        validateRenderables(renderGroup, renderPipes);\n      } else {\n        clearList(renderGroup.childrenRenderablesToUpdate.list, 0);\n      }\n      updateRenderGroupTransforms(renderGroup);\n      if (renderGroup.structureDidChange) {\n        renderGroup.structureDidChange = false;\n        buildInstructions(renderGroup, renderer);\n      } else {\n        updateRenderables(renderGroup);\n      }\n      renderGroup.childrenRenderablesToUpdate.index = 0;\n      renderer.renderPipes.batch.upload(renderGroup.instructionSet);\n    }\n    renderer.globalUniforms.start({\n      worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,\n      worldColor: container.renderGroup.worldColorAlpha\n    });\n    executeInstructions(container.renderGroup, renderPipes);\n    if (renderPipes.uniformBatch) {\n      renderPipes.uniformBatch.renderEnd();\n    }\n    if (transform) {\n      container.renderGroup.localTransform.copyFrom(originalLocalTransform);\n    }\n    container.parent = parent;\n    container.renderGroup.renderGroupParent = renderGroupParent;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nRenderGroupSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"renderGroup\"\n};\nfunction updateRenderables(renderGroup) {\n  const { list, index } = renderGroup.childrenRenderablesToUpdate;\n  for (let i = 0; i < index; i++) {\n    const container = list[i];\n    if (container.didViewUpdate) {\n      renderGroup.updateRenderable(container);\n    }\n  }\n  clearList(list, index);\n}\n\nexport { RenderGroupSystem };\n//# sourceMappingURL=RenderGroupSystem.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\nimport { BatchableSprite } from './BatchableSprite.mjs';\n\n\"use strict\";\nclass SpritePipe {\n  constructor(renderer) {\n    this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);\n    this._destroyRenderableBound = this.destroyRenderable.bind(this);\n    this._renderer = renderer;\n    this._renderer.renderableGC.addManagedHash(this, \"_gpuSpriteHash\");\n  }\n  addRenderable(sprite, instructionSet) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n  }\n  updateRenderable(sprite) {\n    const gpuSprite = this._gpuSpriteHash[sprite.uid];\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    gpuSprite._batcher.updateElement(gpuSprite);\n  }\n  validateRenderable(sprite) {\n    const texture = sprite._texture;\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (gpuSprite.texture._source !== texture._source) {\n      return !gpuSprite._batcher.checkAndUpdateTexture(gpuSprite, texture);\n    }\n    return false;\n  }\n  destroyRenderable(sprite) {\n    const batchableSprite = this._gpuSpriteHash[sprite.uid];\n    BigPool.return(batchableSprite);\n    this._gpuSpriteHash[sprite.uid] = null;\n    sprite.off(\"destroyed\", this._destroyRenderableBound);\n  }\n  _updateBatchableSprite(sprite, batchableSprite) {\n    batchableSprite.bounds = sprite.bounds;\n    batchableSprite.texture = sprite._texture;\n  }\n  _getGpuSprite(sprite) {\n    return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n  }\n  _initGPUSprite(sprite) {\n    const batchableSprite = BigPool.get(BatchableSprite);\n    batchableSprite.renderable = sprite;\n    batchableSprite.transform = sprite.groupTransform;\n    batchableSprite.texture = sprite._texture;\n    batchableSprite.bounds = sprite.bounds;\n    batchableSprite.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n    this._gpuSpriteHash[sprite.uid] = batchableSprite;\n    sprite.on(\"destroyed\", this._destroyRenderableBound);\n    return batchableSprite;\n  }\n  destroy() {\n    for (const i in this._gpuSpriteHash) {\n      BigPool.return(this._gpuSpriteHash[i]);\n    }\n    this._gpuSpriteHash = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nSpritePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"sprite\"\n};\n\nexport { SpritePipe };\n//# sourceMappingURL=SpritePipe.mjs.map\n","import { Color } from '../../../../color/Color.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\n\n\"use strict\";\nconst _BackgroundSystem = class _BackgroundSystem {\n  constructor() {\n    this.clearBeforeRender = true;\n    this._backgroundColor = new Color(0);\n    this.color = this._backgroundColor;\n    this.alpha = 1;\n  }\n  /**\n   * initiates the background system\n   * @param options - the options for the background colors\n   */\n  init(options) {\n    options = { ..._BackgroundSystem.defaultOptions, ...options };\n    this.clearBeforeRender = options.clearBeforeRender;\n    this.color = options.background || options.backgroundColor || this._backgroundColor;\n    this.alpha = options.backgroundAlpha;\n    this._backgroundColor.setAlpha(options.backgroundAlpha);\n  }\n  /** The background color to fill if not transparent */\n  get color() {\n    return this._backgroundColor;\n  }\n  set color(value) {\n    this._backgroundColor.setValue(value);\n  }\n  /** The background color alpha. Setting this to 0 will make the canvas transparent. */\n  get alpha() {\n    return this._backgroundColor.alpha;\n  }\n  set alpha(value) {\n    this._backgroundColor.setAlpha(value);\n  }\n  /** The background color as an [R, G, B, A] array. */\n  get colorRgba() {\n    return this._backgroundColor.toArray();\n  }\n  /**\n   * destroys the background system\n   * @internal\n   * @ignore\n   */\n  destroy() {\n  }\n};\n/** @ignore */\n_BackgroundSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"background\",\n  priority: 0\n};\n/** default options used by the system */\n_BackgroundSystem.defaultOptions = {\n  /**\n   * {@link WebGLOptions.backgroundAlpha}\n   * @default 1\n   */\n  backgroundAlpha: 1,\n  /**\n   * {@link WebGLOptions.backgroundColor}\n   * @default 0x000000\n   */\n  backgroundColor: 0,\n  /**\n   * {@link WebGLOptions.clearBeforeRender}\n   * @default true\n   */\n  clearBeforeRender: true\n};\nlet BackgroundSystem = _BackgroundSystem;\n\nexport { BackgroundSystem };\n//# sourceMappingURL=BackgroundSystem.mjs.map\n","import { extensions, ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { FilterEffect } from '../../../../filters/FilterEffect.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nconst BLEND_MODE_FILTERS = {};\nextensions.handle(ExtensionType.BlendMode, (value) => {\n  if (!value.name) {\n    throw new Error(\"BlendMode extension must have a name property\");\n  }\n  BLEND_MODE_FILTERS[value.name] = value.ref;\n}, (value) => {\n  delete BLEND_MODE_FILTERS[value.name];\n});\nclass BlendModePipe {\n  constructor(renderer) {\n    this._isAdvanced = false;\n    this._filterHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  /**\n   * This ensures that a blendMode switch is added to the instruction set if the blend mode has changed.\n   * @param renderable - The renderable we are adding to the instruction set\n   * @param blendMode - The blend mode of the renderable\n   * @param instructionSet - The instruction set we are adding to\n   */\n  setBlendMode(renderable, blendMode, instructionSet) {\n    if (this._activeBlendMode === blendMode) {\n      if (this._isAdvanced)\n        this._renderableList.push(renderable);\n      return;\n    }\n    this._activeBlendMode = blendMode;\n    if (this._isAdvanced) {\n      this._endAdvancedBlendMode(instructionSet);\n    }\n    this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];\n    if (this._isAdvanced) {\n      this._beginAdvancedBlendMode(instructionSet);\n      this._renderableList.push(renderable);\n    }\n  }\n  _beginAdvancedBlendMode(instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    const blendMode = this._activeBlendMode;\n    if (!BLEND_MODE_FILTERS[blendMode]) {\n      warn(`Unable to assign BlendMode: '${blendMode}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);\n      return;\n    }\n    let filterEffect = this._filterHash[blendMode];\n    if (!filterEffect) {\n      filterEffect = this._filterHash[blendMode] = new FilterEffect();\n      filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode]()];\n    }\n    const instruction = {\n      renderPipeId: \"filter\",\n      action: \"pushFilter\",\n      renderables: [],\n      filterEffect,\n      canBundle: false\n    };\n    this._renderableList = instruction.renderables;\n    instructionSet.add(instruction);\n  }\n  _endAdvancedBlendMode(instructionSet) {\n    this._renderableList = null;\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      action: \"popFilter\",\n      canBundle: false\n    });\n  }\n  /**\n   * called when the instruction build process is starting this will reset internally to the default blend mode\n   * @internal\n   * @ignore\n   */\n  buildStart() {\n    this._isAdvanced = false;\n  }\n  /**\n   * called when the instruction build process is finished, ensuring that if there is an advanced blend mode\n   * active, we add the final render instructions added to the instruction set\n   * @param instructionSet - The instruction set we are adding to\n   * @internal\n   * @ignore\n   */\n  buildEnd(instructionSet) {\n    if (this._isAdvanced) {\n      this._endAdvancedBlendMode(instructionSet);\n    }\n  }\n  /**\n   * @internal\n   * @ignore\n   */\n  destroy() {\n    this._renderer = null;\n    this._renderableList = null;\n    for (const i in this._filterHash) {\n      this._filterHash[i].destroy();\n    }\n    this._filterHash = null;\n  }\n}\n/** @ignore */\nBlendModePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"blendMode\"\n};\n\nexport { BlendModePipe };\n//# sourceMappingURL=BlendModePipe.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Container } from '../../../../scene/container/Container.mjs';\nimport { Texture } from '../texture/Texture.mjs';\n\n\"use strict\";\nconst imageTypes = {\n  png: \"image/png\",\n  jpg: \"image/jpeg\",\n  webp: \"image/webp\"\n};\nconst _ExtractSystem = class _ExtractSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  _normalizeOptions(options, defaults = {}) {\n    if (options instanceof Container || options instanceof Texture) {\n      return {\n        target: options,\n        ...defaults\n      };\n    }\n    return {\n      ...defaults,\n      ...options\n    };\n  }\n  /**\n   * Will return a HTML Image of the target\n   * @param options - The options for creating the image, or the target to extract\n   * @returns - HTML Image of the target\n   */\n  async image(options) {\n    const image = new Image();\n    image.src = await this.base64(options);\n    return image;\n  }\n  /**\n   * Will return a base64 encoded string of this target. It works by calling\n   * `Extract.canvas` and then running toDataURL on that.\n   * @param options - The options for creating the image, or the target to extract\n   */\n  async base64(options) {\n    options = this._normalizeOptions(\n      options,\n      _ExtractSystem.defaultImageOptions\n    );\n    const { format, quality } = options;\n    const canvas = this.canvas(options);\n    if (canvas.toBlob !== void 0) {\n      return new Promise((resolve, reject) => {\n        canvas.toBlob((blob) => {\n          if (!blob) {\n            reject(new Error(\"ICanvas.toBlob failed!\"));\n            return;\n          }\n          const reader = new FileReader();\n          reader.onload = () => resolve(reader.result);\n          reader.onerror = reject;\n          reader.readAsDataURL(blob);\n        }, imageTypes[format], quality);\n      });\n    }\n    if (canvas.toDataURL !== void 0) {\n      return canvas.toDataURL(imageTypes[format], quality);\n    }\n    if (canvas.convertToBlob !== void 0) {\n      const blob = await canvas.convertToBlob({ type: imageTypes[format], quality });\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n      });\n    }\n    throw new Error(\"Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented\");\n  }\n  /**\n   * Creates a Canvas element, renders this target to it and then returns it.\n   * @param options - The options for creating the canvas, or the target to extract\n   * @returns - A Canvas element with the texture rendered on.\n   */\n  canvas(options) {\n    options = this._normalizeOptions(options);\n    const target = options.target;\n    const renderer = this._renderer;\n    if (target instanceof Texture) {\n      return renderer.texture.generateCanvas(target);\n    }\n    const texture = renderer.textureGenerator.generateTexture(options);\n    const canvas = renderer.texture.generateCanvas(texture);\n    texture.destroy();\n    return canvas;\n  }\n  /**\n   * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA\n   * order, with integer values between 0 and 255 (included).\n   * @param options - The options for extracting the image, or the target to extract\n   * @returns - One-dimensional array containing the pixel data of the entire texture\n   */\n  pixels(options) {\n    options = this._normalizeOptions(options);\n    const target = options.target;\n    const renderer = this._renderer;\n    const texture = target instanceof Texture ? target : renderer.textureGenerator.generateTexture(options);\n    const pixelInfo = renderer.texture.getPixels(texture);\n    if (target instanceof Container) {\n      texture.destroy();\n    }\n    return pixelInfo;\n  }\n  /**\n   * Will return a texture of the target\n   * @param options - The options for creating the texture, or the target to extract\n   * @returns - A texture of the target\n   */\n  texture(options) {\n    options = this._normalizeOptions(options);\n    if (options.target instanceof Texture)\n      return options.target;\n    return this._renderer.textureGenerator.generateTexture(options);\n  }\n  /**\n   * Will extract a HTMLImage of the target and download it\n   * @param options - The options for downloading and extracting the image, or the target to extract\n   */\n  download(options) {\n    options = this._normalizeOptions(options);\n    const canvas = this.canvas(options);\n    const link = document.createElement(\"a\");\n    link.download = options.filename ?? \"image.png\";\n    link.href = canvas.toDataURL(\"image/png\");\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n  }\n  /**\n   * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.\n   * @param options - The options for logging the image, or the target to log\n   */\n  log(options) {\n    const width = options.width ?? 200;\n    options = this._normalizeOptions(options);\n    const canvas = this.canvas(options);\n    const base64 = canvas.toDataURL();\n    console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);\n    const style = [\n      \"font-size: 1px;\",\n      `padding: ${width}px ${300}px;`,\n      `background: url(${base64}) no-repeat;`,\n      \"background-size: contain;\"\n    ].join(\" \");\n    console.log(\"%c \", style);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n};\n/** @ignore */\n_ExtractSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"extract\"\n};\n/** Default options for creating an image. */\n_ExtractSystem.defaultImageOptions = {\n  /** The format of the image. */\n  format: \"png\",\n  /** The quality of the image. */\n  quality: 1\n};\nlet ExtractSystem = _ExtractSystem;\n\nexport { ExtractSystem };\n//# sourceMappingURL=ExtractSystem.mjs.map\n","import { TextureSource } from './sources/TextureSource.mjs';\nimport { Texture } from './Texture.mjs';\n\n\"use strict\";\nclass RenderTexture extends Texture {\n  static create(options) {\n    return new RenderTexture({\n      source: new TextureSource(options)\n    });\n  }\n  /**\n   * Resizes the render texture.\n   * @param width - The new width of the render texture.\n   * @param height - The new height of the render texture.\n   * @param resolution - The new resolution of the render texture.\n   * @returns This texture.\n   */\n  resize(width, height, resolution) {\n    this.source.resize(width, height, resolution);\n    return this;\n  }\n}\n\nexport { RenderTexture };\n//# sourceMappingURL=RenderTexture.mjs.map\n","import { Color } from '../../../../color/Color.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds.mjs';\nimport { getLocalBounds } from '../../../../scene/container/bounds/getLocalBounds.mjs';\nimport { Container } from '../../../../scene/container/Container.mjs';\nimport { RenderTexture } from '../texture/RenderTexture.mjs';\n\n\"use strict\";\nconst tempRect = new Rectangle();\nconst tempBounds = new Bounds();\nconst noColor = [0, 0, 0, 0];\nclass GenerateTextureSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  /**\n   * A Useful function that returns a texture of the display object that can then be used to create sprites\n   * This can be quite useful if your container is complicated and needs to be reused multiple times.\n   * @param {GenerateTextureOptions | Container} options - Generate texture options.\n   * @param {Container} [options.container] - If not given, the renderer's resolution is used.\n   * @param {Rectangle} options.region - The region of the container, that shall be rendered,\n   * @param {number} [options.resolution] - The resolution of the texture being generated.\n   *        if no region is specified, defaults to the local bounds of the container.\n   * @param {GenerateTextureSourceOptions} [options.textureSourceOptions] - Texture options for GPU.\n   * @returns a shiny new texture of the container passed in\n   */\n  generateTexture(options) {\n    if (options instanceof Container) {\n      options = {\n        target: options,\n        frame: void 0,\n        textureSourceOptions: {},\n        resolution: void 0\n      };\n    }\n    const resolution = options.resolution || this._renderer.resolution;\n    const antialias = options.antialias || this._renderer.view.antialias;\n    const container = options.target;\n    let clearColor = options.clearColor;\n    if (clearColor) {\n      const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;\n      clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();\n    } else {\n      clearColor = noColor;\n    }\n    const region = options.frame?.copyTo(tempRect) || getLocalBounds(container, tempBounds).rectangle;\n    region.width = Math.max(region.width, 1 / resolution) | 0;\n    region.height = Math.max(region.height, 1 / resolution) | 0;\n    const target = RenderTexture.create({\n      ...options.textureSourceOptions,\n      width: region.width,\n      height: region.height,\n      resolution,\n      antialias\n    });\n    const transform = Matrix.shared.translate(-region.x, -region.y);\n    this._renderer.render({\n      container,\n      transform,\n      target,\n      clearColor\n    });\n    target.source.updateMipmaps();\n    return target;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGenerateTextureSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"textureGenerator\"\n};\n\nexport { GenerateTextureSystem };\n//# sourceMappingURL=GenerateTextureSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Point } from '../../../../maths/point/Point.mjs';\nimport { color32BitToUniform } from '../../../../scene/graphics/gpu/colorToUniform.mjs';\nimport { BindGroup } from '../../gpu/shader/BindGroup.mjs';\nimport { RendererType } from '../../types.mjs';\nimport { UniformGroup } from '../shader/UniformGroup.mjs';\n\n\"use strict\";\nclass GlobalUniformSystem {\n  constructor(renderer) {\n    this._stackIndex = 0;\n    this._globalUniformDataStack = [];\n    this._uniformsPool = [];\n    this._activeUniforms = [];\n    this._bindGroupPool = [];\n    this._activeBindGroups = [];\n    this._renderer = renderer;\n  }\n  reset() {\n    this._stackIndex = 0;\n    for (let i = 0; i < this._activeUniforms.length; i++) {\n      this._uniformsPool.push(this._activeUniforms[i]);\n    }\n    for (let i = 0; i < this._activeBindGroups.length; i++) {\n      this._bindGroupPool.push(this._activeBindGroups[i]);\n    }\n    this._activeUniforms.length = 0;\n    this._activeBindGroups.length = 0;\n  }\n  start(options) {\n    this.reset();\n    this.push(options);\n  }\n  bind({\n    size,\n    projectionMatrix,\n    worldTransformMatrix,\n    worldColor,\n    offset\n  }) {\n    const renderTarget = this._renderer.renderTarget.renderTarget;\n    const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {\n      projectionData: renderTarget,\n      worldTransformMatrix: new Matrix(),\n      worldColor: 4294967295,\n      offset: new Point()\n    };\n    const globalUniformData = {\n      projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,\n      resolution: size || renderTarget.size,\n      worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,\n      worldColor: worldColor || currentGlobalUniformData.worldColor,\n      offset: offset || currentGlobalUniformData.offset,\n      bindGroup: null\n    };\n    const uniformGroup = this._uniformsPool.pop() || this._createUniforms();\n    this._activeUniforms.push(uniformGroup);\n    const uniforms = uniformGroup.uniforms;\n    uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;\n    uniforms.uResolution = globalUniformData.resolution;\n    uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);\n    uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;\n    uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;\n    color32BitToUniform(\n      globalUniformData.worldColor,\n      uniforms.uWorldColorAlpha,\n      0\n    );\n    uniformGroup.update();\n    let bindGroup;\n    if (this._renderer.renderPipes.uniformBatch) {\n      bindGroup = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);\n    } else {\n      bindGroup = this._bindGroupPool.pop() || new BindGroup();\n      this._activeBindGroups.push(bindGroup);\n      bindGroup.setResource(uniformGroup, 0);\n    }\n    globalUniformData.bindGroup = bindGroup;\n    this._currentGlobalUniformData = globalUniformData;\n  }\n  push(options) {\n    this.bind(options);\n    this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;\n  }\n  pop() {\n    this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];\n    if (this._renderer.type === RendererType.WEBGL) {\n      this._currentGlobalUniformData.bindGroup.resources[0].update();\n    }\n  }\n  get bindGroup() {\n    return this._currentGlobalUniformData.bindGroup;\n  }\n  get globalUniformData() {\n    return this._currentGlobalUniformData;\n  }\n  get uniformGroup() {\n    return this._currentGlobalUniformData.bindGroup.resources[0];\n  }\n  _createUniforms() {\n    const globalUniforms = new UniformGroup({\n      uProjectionMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uWorldTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>\n      uWorldColorAlpha: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uResolution: { value: [0, 0], type: \"vec2<f32>\" }\n    }, {\n      isStatic: true\n    });\n    return globalUniforms;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGlobalUniformSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"globalUniforms\"\n};\n\nexport { GlobalUniformSystem };\n//# sourceMappingURL=GlobalUniformSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Ticker } from '../../../ticker/Ticker.mjs';\n\n\"use strict\";\nlet uid = 1;\nclass SchedulerSystem {\n  constructor() {\n    this._tasks = [];\n    /** a small off set to apply to the repeat schedules. This is just to make sure they run at slightly different times */\n    this._offset = 0;\n  }\n  /** Initializes the scheduler system and starts the ticker. */\n  init() {\n    Ticker.system.add(this._update, this);\n  }\n  /**\n   * Schedules a repeating task.\n   * @param func - The function to execute.\n   * @param duration - The interval duration in milliseconds.\n   * @param useOffset - this will spread out tasks so that they do not all run at the same time\n   * @returns The unique identifier for the scheduled task.\n   */\n  repeat(func, duration, useOffset = true) {\n    const id = uid++;\n    let offset = 0;\n    if (useOffset) {\n      this._offset += 1e3;\n      offset = this._offset;\n    }\n    this._tasks.push({\n      func,\n      duration,\n      start: performance.now(),\n      offset,\n      last: performance.now(),\n      repeat: true,\n      id\n    });\n    return id;\n  }\n  /**\n   * Cancels a scheduled task.\n   * @param id - The unique identifier of the task to cancel.\n   */\n  cancel(id) {\n    for (let i = 0; i < this._tasks.length; i++) {\n      if (this._tasks[i].id === id) {\n        this._tasks.splice(i, 1);\n        return;\n      }\n    }\n  }\n  /**\n   * Updates and executes the scheduled tasks.\n   * @private\n   */\n  _update() {\n    const now = performance.now();\n    for (let i = 0; i < this._tasks.length; i++) {\n      const task = this._tasks[i];\n      if (now - task.offset - task.last >= task.duration) {\n        const elapsed = now - task.start;\n        task.func(elapsed);\n        task.last = now;\n      }\n    }\n  }\n  /**\n   * Destroys the scheduler system and removes all tasks.\n   * @internal\n   * @ignore\n   */\n  destroy() {\n    Ticker.system.remove(this._update, this);\n    this._tasks.length = 0;\n  }\n}\n/** @ignore */\nSchedulerSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"scheduler\",\n  priority: 0\n};\n\nexport { SchedulerSystem };\n//# sourceMappingURL=SchedulerSystem.mjs.map\n","import { DOMAdapter } from '../environment/adapter.mjs';\nimport { VERSION } from './const.mjs';\n\n\"use strict\";\nlet saidHello = false;\nfunction sayHello(type) {\n  if (saidHello) {\n    return;\n  }\n  if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf(\"chrome\") > -1) {\n    const args = [\n      `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/\n\n`,\n      \"background: #E72264; padding:5px 0;\",\n      \"background: #6CA2EA; padding:5px 0;\",\n      \"background: #B5D33D; padding:5px 0;\",\n      \"background: #FED23F; padding:5px 0;\",\n      \"color: #FFFFFF; background: #E72264; padding:5px 0;\",\n      \"color: #E72264; background: #FFFFFF; padding:5px 0;\"\n    ];\n    globalThis.console.log(...args);\n  } else if (globalThis.console) {\n    globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);\n  }\n  saidHello = true;\n}\n\nexport { sayHello };\n//# sourceMappingURL=sayHello.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { sayHello } from '../../../../utils/sayHello.mjs';\nimport { RendererType } from '../../types.mjs';\n\n\"use strict\";\nclass HelloSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  /**\n   * It all starts here! This initiates every system, passing in the options for any system by name.\n   * @param options - the config for the renderer and all its systems\n   */\n  init(options) {\n    if (options.hello) {\n      let name = this._renderer.name;\n      if (this._renderer.type === RendererType.WEBGL) {\n        name += ` ${this._renderer.context.webGLVersion}`;\n      }\n      sayHello(name);\n    }\n  }\n}\n/** @ignore */\nHelloSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"hello\",\n  priority: -2\n};\n/** The default options for the system. */\nHelloSystem.defaultOptions = {\n  /** {@link WebGLOptions.hello} */\n  hello: false\n};\n\nexport { HelloSystem };\n//# sourceMappingURL=HelloSystem.mjs.map\n","\"use strict\";\nfunction cleanHash(hash) {\n  let clean = false;\n  for (const i in hash) {\n    if (hash[i] == void 0) {\n      clean = true;\n      break;\n    }\n  }\n  if (!clean)\n    return hash;\n  const cleanHash2 = /* @__PURE__ */ Object.create(null);\n  for (const i in hash) {\n    const value = hash[i];\n    if (value) {\n      cleanHash2[i] = value;\n    }\n  }\n  return cleanHash2;\n}\nfunction cleanArray(arr) {\n  let offset = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] == void 0) {\n      offset++;\n    } else {\n      arr[i - offset] = arr[i];\n    }\n  }\n  arr.length = arr.length - offset;\n  return arr;\n}\n\nexport { cleanArray, cleanHash };\n//# sourceMappingURL=clean.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { cleanHash, cleanArray } from '../../../../utils/data/clean.mjs';\n\n\"use strict\";\nconst _RenderableGCSystem = class _RenderableGCSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this._managedRenderables = [];\n    this._managedHashes = [];\n    this._managedArrays = [];\n    this._renderer = renderer;\n  }\n  init(options) {\n    options = { ..._RenderableGCSystem.defaultOptions, ...options };\n    this.maxUnusedTime = options.renderableGCMaxUnusedTime;\n    this._frequency = options.renderableGCFrequency;\n    this.enabled = options.renderableGCActive;\n  }\n  get enabled() {\n    return !!this._handler;\n  }\n  set enabled(value) {\n    if (this.enabled === value)\n      return;\n    if (value) {\n      this._handler = this._renderer.scheduler.repeat(\n        () => this.run(),\n        this._frequency,\n        false\n      );\n      this._hashHandler = this._renderer.scheduler.repeat(\n        () => {\n          for (const hash of this._managedHashes) {\n            hash.context[hash.hash] = cleanHash(hash.context[hash.hash]);\n          }\n        },\n        this._frequency\n      );\n      this._arrayHandler = this._renderer.scheduler.repeat(\n        () => {\n          for (const array of this._managedArrays) {\n            cleanArray(array.context[array.hash]);\n          }\n        },\n        this._frequency\n      );\n    } else {\n      this._renderer.scheduler.cancel(this._handler);\n      this._renderer.scheduler.cancel(this._hashHandler);\n      this._renderer.scheduler.cancel(this._arrayHandler);\n    }\n  }\n  addManagedHash(context, hash) {\n    this._managedHashes.push({ context, hash });\n  }\n  addManagedArray(context, hash) {\n    this._managedArrays.push({ context, hash });\n  }\n  prerender() {\n    this._now = performance.now();\n  }\n  addRenderable(renderable, instructionSet) {\n    if (!this.enabled)\n      return;\n    renderable._lastUsed = this._now;\n    if (renderable._lastInstructionTick === -1) {\n      this._managedRenderables.push(renderable);\n      renderable.once(\"destroyed\", this._removeRenderable, this);\n    }\n    renderable._lastInstructionTick = instructionSet.tick;\n  }\n  /** Runs the scheduled garbage collection */\n  run() {\n    const now = performance.now();\n    const managedRenderables = this._managedRenderables;\n    const renderPipes = this._renderer.renderPipes;\n    let offset = 0;\n    for (let i = 0; i < managedRenderables.length; i++) {\n      const renderable = managedRenderables[i];\n      if (renderable === null) {\n        offset++;\n        continue;\n      }\n      const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n      const currentIndex = renderGroup?.instructionSet?.tick ?? -1;\n      if (renderable._lastInstructionTick !== currentIndex && now - renderable._lastUsed > this.maxUnusedTime) {\n        if (!renderable.destroyed) {\n          const rp = renderPipes;\n          rp[renderable.renderPipeId].destroyRenderable(renderable);\n        }\n        renderable._lastInstructionTick = -1;\n        offset++;\n        renderable.off(\"destroyed\", this._removeRenderable, this);\n      } else {\n        managedRenderables[i - offset] = renderable;\n      }\n    }\n    managedRenderables.length = managedRenderables.length - offset;\n  }\n  destroy() {\n    this.enabled = false;\n    this._renderer = null;\n    this._managedRenderables.length = 0;\n    this._managedHashes.length = 0;\n    this._managedArrays.length = 0;\n  }\n  _removeRenderable(renderable) {\n    const index = this._managedRenderables.indexOf(renderable);\n    if (index >= 0) {\n      renderable.off(\"destroyed\", this._removeRenderable, this);\n      this._managedRenderables[index] = null;\n    }\n  }\n};\n/** @ignore */\n_RenderableGCSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"renderableGC\",\n  priority: 0\n};\n/** default options for the renderableGCSystem */\n_RenderableGCSystem.defaultOptions = {\n  /**\n   * If set to true, this will enable the garbage collector on the GPU.\n   * @default true\n   */\n  renderableGCActive: true,\n  /**\n   * The maximum idle frames before a texture is destroyed by garbage collection.\n   * @default 60 * 60\n   */\n  renderableGCMaxUnusedTime: 6e4,\n  /**\n   * Frames between two garbage collections.\n   * @default 600\n   */\n  renderableGCFrequency: 3e4\n};\nlet RenderableGCSystem = _RenderableGCSystem;\n\nexport { RenderableGCSystem };\n//# sourceMappingURL=RenderableGCSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\n\n\"use strict\";\nconst _TextureGCSystem = class _TextureGCSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this._renderer = renderer;\n    this.count = 0;\n    this.checkCount = 0;\n  }\n  init(options) {\n    options = { ..._TextureGCSystem.defaultOptions, ...options };\n    this.checkCountMax = options.textureGCCheckCountMax;\n    this.maxIdle = options.textureGCAMaxIdle ?? options.textureGCMaxIdle;\n    this.active = options.textureGCActive;\n  }\n  /**\n   * Checks to see when the last time a texture was used.\n   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n   */\n  postrender() {\n    if (!this._renderer.renderingToScreen) {\n      return;\n    }\n    this.count++;\n    if (!this.active)\n      return;\n    this.checkCount++;\n    if (this.checkCount > this.checkCountMax) {\n      this.checkCount = 0;\n      this.run();\n    }\n  }\n  /**\n   * Checks to see when the last time a texture was used.\n   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n   */\n  run() {\n    const managedTextures = this._renderer.texture.managedTextures;\n    for (let i = 0; i < managedTextures.length; i++) {\n      const texture = managedTextures[i];\n      if (texture.autoGarbageCollect && texture.resource && texture._touched > -1 && this.count - texture._touched > this.maxIdle) {\n        texture._touched = -1;\n        texture.unload();\n      }\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n};\n/** @ignore */\n_TextureGCSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"textureGC\"\n};\n/** default options for the TextureGCSystem */\n_TextureGCSystem.defaultOptions = {\n  /**\n   * If set to true, this will enable the garbage collector on the GPU.\n   * @default true\n   */\n  textureGCActive: true,\n  /**\n   * @deprecated since 8.3.0\n   * @see {@link TextureGCSystem.textureGCMaxIdle}\n   */\n  textureGCAMaxIdle: null,\n  /**\n   * The maximum idle frames before a texture is destroyed by garbage collection.\n   * @default 60 * 60\n   */\n  textureGCMaxIdle: 60 * 60,\n  /**\n   * Frames between two garbage collections.\n   * @default 600\n   */\n  textureGCCheckCountMax: 600\n};\nlet TextureGCSystem = _TextureGCSystem;\n\nexport { TextureGCSystem };\n//# sourceMappingURL=TextureGCSystem.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation.mjs';\nimport { RenderTarget } from '../renderTarget/RenderTarget.mjs';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture.mjs';\n\n\"use strict\";\nconst _ViewSystem = class _ViewSystem {\n  /**\n   * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.\n   * @member {boolean}\n   */\n  get autoDensity() {\n    return this.texture.source.autoDensity;\n  }\n  set autoDensity(value) {\n    this.texture.source.autoDensity = value;\n  }\n  /** The resolution / device pixel ratio of the renderer. */\n  get resolution() {\n    return this.texture.source._resolution;\n  }\n  set resolution(value) {\n    this.texture.source.resize(\n      this.texture.source.width,\n      this.texture.source.height,\n      value\n    );\n  }\n  /**\n   * initiates the view system\n   * @param options - the options for the view\n   */\n  init(options) {\n    options = {\n      ..._ViewSystem.defaultOptions,\n      ...options\n    };\n    if (options.view) {\n      deprecation(v8_0_0, \"ViewSystem.view has been renamed to ViewSystem.canvas\");\n      options.canvas = options.view;\n    }\n    this.screen = new Rectangle(0, 0, options.width, options.height);\n    this.canvas = options.canvas || DOMAdapter.get().createCanvas();\n    this.antialias = !!options.antialias;\n    this.texture = getCanvasTexture(this.canvas, options);\n    this.renderTarget = new RenderTarget({\n      colorTextures: [this.texture],\n      depth: !!options.depth,\n      isRoot: true\n    });\n    this.texture.source.transparent = options.backgroundAlpha < 1;\n    this.resolution = options.resolution;\n  }\n  /**\n   * Resizes the screen and canvas to the specified dimensions.\n   * @param desiredScreenWidth - The new width of the screen.\n   * @param desiredScreenHeight - The new height of the screen.\n   * @param resolution\n   */\n  resize(desiredScreenWidth, desiredScreenHeight, resolution) {\n    this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n    this.screen.width = this.texture.frame.width;\n    this.screen.height = this.texture.frame.height;\n  }\n  /**\n   * Destroys this System and optionally removes the canvas from the dom.\n   * @param {options | false} options - The options for destroying the view, or \"false\".\n   * @param options.removeView - Whether to remove the view element from the DOM. Defaults to `false`.\n   */\n  destroy(options = false) {\n    const removeView = typeof options === \"boolean\" ? options : !!options?.removeView;\n    if (removeView && this.canvas.parentNode) {\n      this.canvas.parentNode.removeChild(this.canvas);\n    }\n  }\n};\n/** @ignore */\n_ViewSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"view\",\n  priority: 0\n};\n/** The default options for the view system. */\n_ViewSystem.defaultOptions = {\n  /**\n   * {@link WebGLOptions.width}\n   * @default 800\n   */\n  width: 800,\n  /**\n   * {@link WebGLOptions.height}\n   * @default 600\n   */\n  height: 600,\n  /**\n   * {@link WebGLOptions.autoDensity}\n   * @default false\n   */\n  autoDensity: false,\n  /**\n   * {@link WebGLOptions.antialias}\n   * @default false\n   */\n  antialias: false\n};\nlet ViewSystem = _ViewSystem;\n\nexport { ViewSystem };\n//# sourceMappingURL=ViewSystem.mjs.map\n","import { CustomRenderPipe } from '../../../../scene/container/CustomRenderPipe.mjs';\nimport { RenderGroupPipe } from '../../../../scene/container/RenderGroupPipe.mjs';\nimport { RenderGroupSystem } from '../../../../scene/container/RenderGroupSystem.mjs';\nimport { SpritePipe } from '../../../../scene/sprite/SpritePipe.mjs';\nimport { RendererInitHook } from '../../../../utils/global/globalHooks.mjs';\nimport { BatcherPipe } from '../../../batcher/shared/BatcherPipe.mjs';\nimport { AlphaMaskPipe } from '../../../mask/alpha/AlphaMaskPipe.mjs';\nimport { ColorMaskPipe } from '../../../mask/color/ColorMaskPipe.mjs';\nimport { StencilMaskPipe } from '../../../mask/stencil/StencilMaskPipe.mjs';\nimport { BackgroundSystem } from '../background/BackgroundSystem.mjs';\nimport { BlendModePipe } from '../blendModes/BlendModePipe.mjs';\nimport { ExtractSystem } from '../extract/ExtractSystem.mjs';\nimport { GenerateTextureSystem } from '../extract/GenerateTextureSystem.mjs';\nimport { GlobalUniformSystem } from '../renderTarget/GlobalUniformSystem.mjs';\nimport { SchedulerSystem } from '../SchedulerSystem.mjs';\nimport { HelloSystem } from '../startup/HelloSystem.mjs';\nimport { RenderableGCSystem } from '../texture/RenderableGCSystem.mjs';\nimport { TextureGCSystem } from '../texture/TextureGCSystem.mjs';\nimport { ViewSystem } from '../view/ViewSystem.mjs';\n\n\"use strict\";\nconst SharedSystems = [\n  BackgroundSystem,\n  GlobalUniformSystem,\n  HelloSystem,\n  ViewSystem,\n  RenderGroupSystem,\n  TextureGCSystem,\n  GenerateTextureSystem,\n  ExtractSystem,\n  RendererInitHook,\n  RenderableGCSystem,\n  SchedulerSystem\n];\nconst SharedRenderPipes = [\n  BlendModePipe,\n  BatcherPipe,\n  SpritePipe,\n  RenderGroupPipe,\n  AlphaMaskPipe,\n  StencilMaskPipe,\n  ColorMaskPipe,\n  CustomRenderPipe\n];\n\nexport { SharedRenderPipes, SharedSystems };\n//# sourceMappingURL=SharedSystems.mjs.map\n"],"names":["_Filter","Shader","options","State","filterManager","input","output","clearMode","value","gpu","gl","rest","gpuProgram","glProgram","GpuProgram","GlProgram","Filter","fragment","vertex","source","MaskFilter","sprite","textureMatrix","TextureMatrix","filterUniforms","UniformGroup","Matrix","_BatcherPipe","renderer","adaptor","_b","_a","name","instructionSet","batchers","DefaultBatcher","i","batchableObject","batch","batches","geometry","batcher","shader","ExtensionType","BatcherPipe","extensions","textureBit","textureBitGl","buildInstructions","renderGroup","rendererOrPipes","root","renderPipes","collectAllRenderablesAdvanced","collectAllRenderables","container","collectAllRenderablesSimple","renderable","renderableGC","children","length","isRoot","effect","renderPipeId","tempBounds","Bounds","AlphaMaskEffect","FilterEffect","Sprite","Texture","AlphaMaskPipe","mask","maskedContainer","maskContainer","_maskedContainer","instruction","renderMask","filterEffect","BigPool","bounds","getGlobalBounds","colorTextureSource","filterTexture","TexturePool","maskData","RendererType","ColorMaskPipe","_container","colorStack","currentColor","_mask","StencilMaskPipe","instructionsLength","renderTargetUid","maskStackIndex","STENCIL_MODES","CLEAR","ensureAttributes","extractedData","attribute","attributeData","warn","ensureStartAndStride","buffers","attributes","tempStride","tempStart","j","buffer","getAttributeInfoFromFormat","GpuStencilModesToPixi","UboSystem","unsafeEvalSupported","uniformGroup","uniformData","Buffer","BufferUsage","uniformGroupSignature","elements","layout","syncFunction","uboElements","data","offset","uniformGroupData","synced","uniformParsers","createUboSyncFunction","parserCode","arrayGenerationFunction","singleSettersMap","funcFragments","prev","uboElement","parsed","template","fragmentSrc","loopMatrix","col","row","uboSyncFunctionsSTD40","uboSyncFunctionsWGSL","calculateProjection","pm","x","y","width","height","flipY","sign","canvasCache","getCanvasTexture","canvas","texture","CanvasSource","onDestroy","isRenderingToScreen","renderTarget","resource","_RenderTarget","descriptor","uid","TextureSource","colorSource","_size","resolution","skipColorTexture","colorTexture","RenderTarget","RenderTargetSystem","Rectangle","SystemRunner","target","clear","clearColor","frame","renderSurface","didChange","gpuRenderTarget","viewport","pixelWidth","pixelHeight","currentRenderTargetData","sourceRenderSurfaceTexture","destinationTexture","originSrc","size","originDest","key","BufferResource","EventEmitter","destroyBuffer","CustomRenderPipe","executeInstructions","instructions","RenderGroupPipe","clearList","list","index","collectRenderGroups","out","mixHexColors","color1","color2","ratio","r1","g1","b1","r2","g2","b2","r","g","b","WHITE_BGR","mixColors","localBGRColor","parentBGRColor","tempContainer","Container","UPDATE_BLEND_COLOR_VISIBLE","UPDATE_VISIBLE","UPDATE_COLOR","UPDATE_BLEND","updateRenderGroupTransforms","updateChildRenderGroups","updateRenderGroupTransform","childrenToUpdate","updateTick","renderGroupDepth","childrenAtDepth","child","updateTransformAndChildren","worldAlpha","renderGroupParent","updateFlags","localTransform","parent","updateColorBlendVisibility","groupAlpha","validateRenderables","rebuildRequired","tempMatrix","RenderGroupSystem","transform","renderGroups","originalLocalTransform","updateRenderables","SpritePipe","gpuSprite","batchableSprite","BatchableSprite","_BackgroundSystem","Color","BackgroundSystem","BLEND_MODE_FILTERS","BlendModePipe","blendMode","imageTypes","_ExtractSystem","defaults","image","format","quality","resolve","reject","blob","reader","pixelInfo","link","base64","style","ExtractSystem","RenderTexture","tempRect","noColor","GenerateTextureSystem","antialias","region","getLocalBounds","GlobalUniformSystem","projectionMatrix","worldTransformMatrix","worldColor","currentGlobalUniformData","Point","globalUniformData","uniforms","color32BitToUniform","bindGroup","BindGroup","SchedulerSystem","Ticker","func","duration","useOffset","id","now","task","elapsed","saidHello","sayHello","type","DOMAdapter","args","VERSION","HelloSystem","cleanHash","hash","clean","cleanHash2","cleanArray","arr","_RenderableGCSystem","array","context","managedRenderables","currentIndex","RenderableGCSystem","_TextureGCSystem","managedTextures","TextureGCSystem","_ViewSystem","deprecation","v8_0_0","desiredScreenWidth","desiredScreenHeight","ViewSystem","SharedSystems","RendererInitHook","SharedRenderPipes"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47]}